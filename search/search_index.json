{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 Mechanics Problem 1: Investigating the Range as a Function of the Angle of Projection 1. Theoretical Foundation To derive the governing equations of motion for a projectile, we start with Newton\u2019s second law in a vacuum (no air resistance). The motion occurs in two dimensions: horizontal (x) and vertical (y). The only force acting is gravity, with acceleration $ g $, directed downward. Equations of Motion Horizontal motion : No acceleration, so: $$ x(t) = v_0 \\cos(\\theta) \\cdot t $$ where \\(v_0\\) is the initial velocity, \\(\\theta\\) is the angle of projection, and \\(t\\) is time. - Vertical motion : Acceleration is $ -g $, so: $$ y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 $$ Solving for Time of Flight The projectile returns to the ground when $ y(t) = 0 $: $$ 0 = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 $$ Factorizing: $$ t \\left( v_0 \\sin(\\theta) - \\frac{1}{2} g t \\right) = 0 $$ Solutions: $ t = 0 $ (launch) or: $$ t = \\frac{2 v_0 \\sin(\\theta)}{g} $$ This is the time of flight. Range Equation Substitute the time of flight into the horizontal equation: $$ R = x\\left(\\frac{2 v_0 \\sin(\\theta)}{g}\\right) = v_0 \\cos(\\theta) \\cdot \\frac{2 v_0 \\sin(\\theta)}{g} = \\frac{2 v_0^2 \\sin(\\theta) \\cos(\\theta)}{g} $$ Using the trigonometric identity $ \\sin(2\\theta) = 2 \\sin(\\theta) \\cos(\\theta) $: $$ R = \\frac{v_0^2 \\sin(2\\theta)}{g} $$ This is the range as a function of the angle of projection. Different initial conditions ($ v_0 $, $ g $) yield a family of solutions, scaling the range accordingly. 2. Analysis of the Range The range \\(R\\) depends on \\(\\theta\\) through \\(\\sin(2\\theta)\\) : - \\(R\\) is maximized when \\(\\sin(2\\theta) = 1\\) , i.e., \\ \\(2\\theta = 90^\\circ\\) , so \\(\\theta = 45^\\circ\\) . - \\(R = 0\\) when \\(\\sin(2\\theta) = 0\\) , i.e., \\(\\theta = 0^\\circ\\) or \\(90^\\circ\\) . - The relationship is symmetric about \\(45^\\circ\\) (e.g.,$ \\theta = 30^\\circ$ and \\(60^\\circ\\) give the same range). Influence of Other Parameters Initial Velocity ( \\(v_0\\) ) : \\(R \\propto v_0^2\\) , so doubling$ v_0$ quadruples the range. Gravitational Acceleration ( \\(g\\) ) : \\(R \\propto 1/g\\) , so a smaller \\(g\\) (e.g., on the Moon) increases the range. 3. Practical Applications This model assumes a flat surface and no air resistance, but it can be adapted: - Uneven Terrain : Adjust the landing height in the vertical equation, solving for \\(t\\) when \\(y(t) = h\\) . This complicates the range formula. - Air Resistance : Introduce a drag force proportional to velocity (e.g., \\(F_d = -k v\\) ), turning the equations into nonlinear differential equations, typically solved numerically. - Real-World Examples : Artillery, sports (e.g., golf, soccer), or space launches (with modified \\(g\\) ). import numpy as np import matplotlib.pyplot as plt Constants g = 9.81 # gravitational acceleration (m/s^2) Function to calculate range def calculate_range(v0, theta_deg): theta_rad = np.radians(theta_deg) # Convert degrees to radians R = (v0**2 * np.sin(2 * theta_rad)) / g return R Angles from 0 to 90 degrees theta = np.linspace(0, 90, 181) # 181 points for smooth curve Different initial velocities v0_values = [10, 20, 30] # m/s Plotting plt.figure(figsize=(10, 6)) for v0 in v0_values: R = calculate_range(v0, theta) plt.plot(theta, R, label=f'v0 = {v0} m/s') Formatting the plot plt.title('Range vs Angle of Projection') plt.xlabel('Angle of Projection (degrees)') plt.ylabel('Range (meters)') plt.grid(True) plt.legend() plt.show()","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#mechanics","text":"","title":"Mechanics"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1-investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"Problem 1: Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"To derive the governing equations of motion for a projectile, we start with Newton\u2019s second law in a vacuum (no air resistance). The motion occurs in two dimensions: horizontal (x) and vertical (y). The only force acting is gravity, with acceleration $ g $, directed downward.","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#equations-of-motion","text":"Horizontal motion : No acceleration, so: $$ x(t) = v_0 \\cos(\\theta) \\cdot t $$ where \\(v_0\\) is the initial velocity, \\(\\theta\\) is the angle of projection, and \\(t\\) is time. - Vertical motion : Acceleration is $ -g $, so: $$ y(t) = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 $$","title":"Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#solving-for-time-of-flight","text":"The projectile returns to the ground when $ y(t) = 0 $: $$ 0 = v_0 \\sin(\\theta) \\cdot t - \\frac{1}{2} g t^2 $$ Factorizing: $$ t \\left( v_0 \\sin(\\theta) - \\frac{1}{2} g t \\right) = 0 $$ Solutions: $ t = 0 $ (launch) or: $$ t = \\frac{2 v_0 \\sin(\\theta)}{g} $$ This is the time of flight.","title":"Solving for Time of Flight"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#range-equation","text":"Substitute the time of flight into the horizontal equation: $$ R = x\\left(\\frac{2 v_0 \\sin(\\theta)}{g}\\right) = v_0 \\cos(\\theta) \\cdot \\frac{2 v_0 \\sin(\\theta)}{g} = \\frac{2 v_0^2 \\sin(\\theta) \\cos(\\theta)}{g} $$ Using the trigonometric identity $ \\sin(2\\theta) = 2 \\sin(\\theta) \\cos(\\theta) $: $$ R = \\frac{v_0^2 \\sin(2\\theta)}{g} $$ This is the range as a function of the angle of projection. Different initial conditions ($ v_0 $, $ g $) yield a family of solutions, scaling the range accordingly.","title":"Range Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#_1","text":"","title":""},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"The range \\(R\\) depends on \\(\\theta\\) through \\(\\sin(2\\theta)\\) : - \\(R\\) is maximized when \\(\\sin(2\\theta) = 1\\) , i.e., \\ \\(2\\theta = 90^\\circ\\) , so \\(\\theta = 45^\\circ\\) . - \\(R = 0\\) when \\(\\sin(2\\theta) = 0\\) , i.e., \\(\\theta = 0^\\circ\\) or \\(90^\\circ\\) . - The relationship is symmetric about \\(45^\\circ\\) (e.g.,$ \\theta = 30^\\circ$ and \\(60^\\circ\\) give the same range).","title":"2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#influence-of-other-parameters","text":"Initial Velocity ( \\(v_0\\) ) : \\(R \\propto v_0^2\\) , so doubling$ v_0$ quadruples the range. Gravitational Acceleration ( \\(g\\) ) : \\(R \\propto 1/g\\) , so a smaller \\(g\\) (e.g., on the Moon) increases the range.","title":"Influence of Other Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"This model assumes a flat surface and no air resistance, but it can be adapted: - Uneven Terrain : Adjust the landing height in the vertical equation, solving for \\(t\\) when \\(y(t) = h\\) . This complicates the range formula. - Air Resistance : Introduce a drag force proportional to velocity (e.g., \\(F_d = -k v\\) ), turning the equations into nonlinear differential equations, typically solved numerically. - Real-World Examples : Artillery, sports (e.g., golf, soccer), or space launches (with modified \\(g\\) ). import numpy as np import matplotlib.pyplot as plt","title":"3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#constants","text":"g = 9.81 # gravitational acceleration (m/s^2)","title":"Constants"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#function-to-calculate-range","text":"def calculate_range(v0, theta_deg): theta_rad = np.radians(theta_deg) # Convert degrees to radians R = (v0**2 * np.sin(2 * theta_rad)) / g return R","title":"Function to calculate range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#angles-from-0-to-90-degrees","text":"theta = np.linspace(0, 90, 181) # 181 points for smooth curve","title":"Angles from 0 to 90 degrees"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#different-initial-velocities","text":"v0_values = [10, 20, 30] # m/s","title":"Different initial velocities"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#plotting","text":"plt.figure(figsize=(10, 6)) for v0 in v0_values: R = calculate_range(v0, theta) plt.plot(theta, R, label=f'v0 = {v0} m/s')","title":"Plotting"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#formatting-the-plot","text":"plt.title('Range vs Angle of Projection') plt.xlabel('Angle of Projection (degrees)') plt.ylabel('Range (meters)') plt.grid(True) plt.legend() plt.show()","title":"Formatting the plot"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 Motivation The forced damped pendulum is a fascinating example of a physical system that exhibits complex dynamics due to the interplay between damping, restoring forces, and external driving forces. In many real-world systems, forces like damping and external driving forces significantly influence the behavior of oscillatory motion, leading to a variety of phenomena such as resonance, chaotic motion, and quasiperiodicity. Understanding these dynamics is essential not only in physics but also in fields like engineering, environmental science, and biomechanics. Investigating the Dynamics of a Forced Damped Pendulum 1. Theoretical Foundation The motion of a forced damped pendulum can be described by the following second-order nonlinear differential equation: \\[ \\frac{d^2 \\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin(\\theta) = A \\cos(\\omega t) \\] Where: - \\(\\theta\\) is the angular displacement, - \\(\\gamma\\) is the damping coefficient, - \\(g\\) is the gravitational acceleration, - \\(L\\) is the length of the pendulum, - \\(A\\) is the amplitude of the driving force, - \\(\\omega\\) is the frequency of the driving force. Small-Angle Approximation For small angles ( \\(\\theta \\ll 1\\) ), we can approximate \\(\\sin(\\theta) \\approx \\theta\\) , leading to the following simplified linear equation: \\[ \\frac{d^2 \\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(\\omega t) \\] This is a linear second-order differential equation with constant coefficients, and its general solution can be found using standard methods for solving linear differential equations. Solution to the Homogeneous Equation The homogeneous part of the equation ( \\(A = 0\\) ) is: \\[ \\frac{d^2 \\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = 0 \\] This is a damped harmonic oscillator equation, whose solution depends on the discriminant \\(\\Delta = \\gamma^2 - 4 \\frac{g}{L}\\) . The behavior of the system depends on this discriminant: If \\(\\Delta > 0\\) (overdamped), the system returns to equilibrium without oscillating. If \\(\\Delta = 0\\) (critically damped), the system returns to equilibrium as quickly as possible without oscillating. If \\(\\Delta < 0\\) (underdamped), the system oscillates with exponentially decaying amplitude. Forced Response For a driven pendulum with \\(A \\neq 0\\) , the solution takes the form of a particular solution superimposed on the homogeneous solution: \\[ \\theta(t) = \\theta_h(t) + \\theta_p(t) \\] Where \\(\\theta_p(t)\\) is the particular solution. This particular solution can be found using the method of undetermined coefficients, which leads to a solution of the form: \\[ \\theta_p(t) = \\frac{A}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (\\gamma \\omega)^2}} \\cos(\\omega t - \\delta) \\] Where: - \\(\\omega_0 = \\sqrt{\\frac{g}{L}}\\) is the natural frequency of the pendulum, - \\(\\delta\\) is the phase shift between the driving force and the pendulum's motion. Resonance Condition Resonance occurs when the driving frequency \\(\\omega\\) matches the natural frequency \\(\\omega_0\\) of the pendulum. In this case, the amplitude of oscillation increases significantly due to the constructive interference between the driving force and the motion of the pendulum. The resonance condition is given by: \\[ \\omega = \\omega_0 \\] In this condition, the system can absorb energy from the driving force efficiently, which can lead to large oscillations. 2. Analysis of Dynamics Now, let's explore how different parameters affect the dynamics of the forced damped pendulum. Parameters Damping coefficient ( \\(\\gamma\\) ) : Controls the rate of energy loss. Increasing damping reduces oscillation amplitude. Driving amplitude ( \\(A\\) ) : Affects the amplitude of the oscillations, with larger values leading to larger oscillations. Driving frequency ( \\(\\omega\\) ) : Determines the frequency of the external force. When close to the natural frequency, resonance occurs. Numerical Simulation We will use a numerical approach to simulate the dynamics of the forced damped pendulum for various values of the damping coefficient, driving amplitude, and driving frequency. The equation will be solved using the Runge-Kutta method , which is an efficient way to solve differential equations numerically. 3. Python Implementation import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp Parameters \\(g = 9.81\\) # gravitational acceleration (m/s^2) \\(L = 1.0\\) # length of the pendulum (m) \\(gamma = 0.1\\) # damping coefficient \\(A = 1.0\\) # amplitude of the external force \\(omega = 1.0\\) # driving frequency \\(theta_0 = 0.2\\) # initial angle (radians) \\(theta_dot_0 = 0.0\\) # initial angular velocity (rad/s) Natural frequency \\[ omega_0 = np.sqrt(g / L) \\] Differential equation for the forced damped pendulum \\(def pendulum_eq(t, y, gamma, A, omega, omega_0):\\) \\(theta, theta_dot = y\\) \\(dtheta_dt = theta_dot\\) \\(dtheta_dot_dt = -gamma * theta_dot - (g / L) * np.sin(theta) + A * np.cos(omega * t)\\) \\(return [dtheta_dt, dtheta_dot_dt]\\) Time span and initial conditions \\[ t_span = (0, 50) y0 = [theta_0, theta_dot_0] t_eval = np.linspace(0, 50, 1000) \\] Solve the differential equation using Runge-Kutta method $ sol = solve_ivp(pendulum_eq, t_span, y0, t_eval=t_eval, args=(gamma, A, omega, omega_0)) $ Plotting the results plt.figure(figsize=(10, 6)) plt.plot(sol.t, sol.y[0], label=r' \\(\\theta(t)\\) ') plt.title('Forced Damped Pendulum Motion') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.grid(True) plt.legend() plt.show() Plot Phase Space (theta vs. theta_dot) plt.figure(figsize=(10, 6)) plt.plot(sol.y[0], sol.y[1], label='Phase Space') plt.title('Phase Space of the Forced Damped Pendulum') plt.xlabel(r' \\(\\theta\\) (radians)') plt.ylabel(r' \\(\\dot{\\theta}\\) (rad/s)') plt.grid(True) plt.legend() plt.show()","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#motivation","text":"The forced damped pendulum is a fascinating example of a physical system that exhibits complex dynamics due to the interplay between damping, restoring forces, and external driving forces. In many real-world systems, forces like damping and external driving forces significantly influence the behavior of oscillatory motion, leading to a variety of phenomena such as resonance, chaotic motion, and quasiperiodicity. Understanding these dynamics is essential not only in physics but also in fields like engineering, environmental science, and biomechanics.","title":"Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"The motion of a forced damped pendulum can be described by the following second-order nonlinear differential equation: \\[ \\frac{d^2 \\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\frac{g}{L} \\sin(\\theta) = A \\cos(\\omega t) \\] Where: - \\(\\theta\\) is the angular displacement, - \\(\\gamma\\) is the damping coefficient, - \\(g\\) is the gravitational acceleration, - \\(L\\) is the length of the pendulum, - \\(A\\) is the amplitude of the driving force, - \\(\\omega\\) is the frequency of the driving force.","title":"1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#small-angle-approximation","text":"For small angles ( \\(\\theta \\ll 1\\) ), we can approximate \\(\\sin(\\theta) \\approx \\theta\\) , leading to the following simplified linear equation: \\[ \\frac{d^2 \\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = A \\cos(\\omega t) \\] This is a linear second-order differential equation with constant coefficients, and its general solution can be found using standard methods for solving linear differential equations.","title":"Small-Angle Approximation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#solution-to-the-homogeneous-equation","text":"The homogeneous part of the equation ( \\(A = 0\\) ) is: \\[ \\frac{d^2 \\theta}{dt^2} + \\gamma \\frac{d\\theta}{dt} + \\frac{g}{L} \\theta = 0 \\] This is a damped harmonic oscillator equation, whose solution depends on the discriminant \\(\\Delta = \\gamma^2 - 4 \\frac{g}{L}\\) . The behavior of the system depends on this discriminant: If \\(\\Delta > 0\\) (overdamped), the system returns to equilibrium without oscillating. If \\(\\Delta = 0\\) (critically damped), the system returns to equilibrium as quickly as possible without oscillating. If \\(\\Delta < 0\\) (underdamped), the system oscillates with exponentially decaying amplitude.","title":"Solution to the Homogeneous Equation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#forced-response","text":"For a driven pendulum with \\(A \\neq 0\\) , the solution takes the form of a particular solution superimposed on the homogeneous solution: \\[ \\theta(t) = \\theta_h(t) + \\theta_p(t) \\] Where \\(\\theta_p(t)\\) is the particular solution. This particular solution can be found using the method of undetermined coefficients, which leads to a solution of the form: \\[ \\theta_p(t) = \\frac{A}{\\sqrt{(\\omega_0^2 - \\omega^2)^2 + (\\gamma \\omega)^2}} \\cos(\\omega t - \\delta) \\] Where: - \\(\\omega_0 = \\sqrt{\\frac{g}{L}}\\) is the natural frequency of the pendulum, - \\(\\delta\\) is the phase shift between the driving force and the pendulum's motion.","title":"Forced Response"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance-condition","text":"Resonance occurs when the driving frequency \\(\\omega\\) matches the natural frequency \\(\\omega_0\\) of the pendulum. In this case, the amplitude of oscillation increases significantly due to the constructive interference between the driving force and the motion of the pendulum. The resonance condition is given by: \\[ \\omega = \\omega_0 \\] In this condition, the system can absorb energy from the driving force efficiently, which can lead to large oscillations.","title":"Resonance Condition"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"Now, let's explore how different parameters affect the dynamics of the forced damped pendulum.","title":"2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#parameters","text":"Damping coefficient ( \\(\\gamma\\) ) : Controls the rate of energy loss. Increasing damping reduces oscillation amplitude. Driving amplitude ( \\(A\\) ) : Affects the amplitude of the oscillations, with larger values leading to larger oscillations. Driving frequency ( \\(\\omega\\) ) : Determines the frequency of the external force. When close to the natural frequency, resonance occurs.","title":"Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#numerical-simulation","text":"We will use a numerical approach to simulate the dynamics of the forced damped pendulum for various values of the damping coefficient, driving amplitude, and driving frequency. The equation will be solved using the Runge-Kutta method , which is an efficient way to solve differential equations numerically.","title":"Numerical Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-python-implementation","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp","title":"3. Python Implementation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#parameters_1","text":"\\(g = 9.81\\) # gravitational acceleration (m/s^2) \\(L = 1.0\\) # length of the pendulum (m) \\(gamma = 0.1\\) # damping coefficient \\(A = 1.0\\) # amplitude of the external force \\(omega = 1.0\\) # driving frequency \\(theta_0 = 0.2\\) # initial angle (radians) \\(theta_dot_0 = 0.0\\) # initial angular velocity (rad/s)","title":"Parameters"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#natural-frequency","text":"\\[ omega_0 = np.sqrt(g / L) \\]","title":"Natural frequency"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#differential-equation-for-the-forced-damped-pendulum","text":"\\(def pendulum_eq(t, y, gamma, A, omega, omega_0):\\) \\(theta, theta_dot = y\\) \\(dtheta_dt = theta_dot\\) \\(dtheta_dot_dt = -gamma * theta_dot - (g / L) * np.sin(theta) + A * np.cos(omega * t)\\) \\(return [dtheta_dt, dtheta_dot_dt]\\)","title":"Differential equation for the forced damped pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#time-span-and-initial-conditions","text":"\\[ t_span = (0, 50) y0 = [theta_0, theta_dot_0] t_eval = np.linspace(0, 50, 1000) \\]","title":"Time span and initial conditions"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#solve-the-differential-equation-using-runge-kutta-method","text":"$ sol = solve_ivp(pendulum_eq, t_span, y0, t_eval=t_eval, args=(gamma, A, omega, omega_0)) $","title":"Solve the differential equation using Runge-Kutta method"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#plotting-the-results","text":"plt.figure(figsize=(10, 6)) plt.plot(sol.t, sol.y[0], label=r' \\(\\theta(t)\\) ') plt.title('Forced Damped Pendulum Motion') plt.xlabel('Time (s)') plt.ylabel('Angle (radians)') plt.grid(True) plt.legend() plt.show()","title":"Plotting the results"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#plot-phase-space-theta-vs-theta_dot","text":"plt.figure(figsize=(10, 6)) plt.plot(sol.y[0], sol.y[1], label='Phase Space') plt.title('Phase Space of the Forced Damped Pendulum') plt.xlabel(r' \\(\\theta\\) (radians)') plt.ylabel(r' \\(\\dot{\\theta}\\) (rad/s)') plt.grid(True) plt.legend() plt.show()","title":"Plot Phase Space (theta vs. theta_dot)"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 Gravity: Orbital Period and Orbital Radius Kepler's Third Law Kepler\u2019s Third Law states that the square of the orbital period \\(T^2\\) is proportional to the cube of the orbital radius \\(r^3\\) : \\[ T^2 \\propto r^3 \\] This relationship can be derived from Newton's law of gravitation and circular motion dynamics. Using Newton\u2019s law of universal gravitation: $$ F = \\frac{G M m}{r^2} $$ For circular orbits, the centripetal force required to keep a body in orbit is: $$ F = \\frac{m v^2}{r} $$ Equating the gravitational force to the centripetal force: $$ \\frac{G M m}{r^2} = \\frac{m v^2}{r} $$ Since the orbital velocity $ v $ is related to the orbital period $ T $ by: $$ v = \\frac{2 \\pi r}{T} $$ Substituting $ v $ into the equation: $$ \\frac{G M m}{r^2} = \\frac{m (2 \\pi r)^2}{T^2 r} $$ Simplifying: $$ T^2 = \\frac{4 \\pi^2}{G M} r^3 $$ This confirms Kepler's Third Law: $ T^2 \\propto r^3 $. Python Simulation import numpy as np import matplotlib.pyplot as plt from scipy.constants import G Constants M = 5.972e24 # Mass of Earth (kg) R_Earth = 6.371e6 # Radius of Earth (m) Define function to compute orbital period def orbital_period(radius, mass=M): return 2 * np.pi * np.sqrt(radius**3 / (G * mass)) Generate orbital radii radii = np.linspace(R_Earth + 200e3, R_Earth + 1e7, 100) # 200 km to 10000 km above Earth periods = orbital_period(radii) Plot T^2 vs. r^3 plt.figure(figsize=(8, 6)) plt.plot(radii 3, periods 2, label=\" \\(T^2 \\propto r^3\\) \", color='b') plt.xlabel(\"Orbital Radius Cubed (m^3)\") plt.ylabel(\"Orbital Period Squared (s^2)\") plt.title(\"Verification of Kepler's Third Law\") plt.legend() plt.grid() plt.show() Implications and Applications Kepler\u2019s Third Law allows astronomers to determine planetary masses and distances. It applies to satellites, exoplanets, and even galaxies, aiding in the measurement of cosmic scales. The law extends to elliptical orbits with semi-major axis replacing the circular radius. Conclusion The relationship \\(T^2 \\propto r^3\\) is fundamental in celestial mechanics. Our simulation verifies this principle, confirming its role in planetary motion and satellite dynamics.","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#gravity-orbital-period-and-orbital-radius","text":"","title":"Gravity: Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#keplers-third-law","text":"Kepler\u2019s Third Law states that the square of the orbital period \\(T^2\\) is proportional to the cube of the orbital radius \\(r^3\\) : \\[ T^2 \\propto r^3 \\] This relationship can be derived from Newton's law of gravitation and circular motion dynamics. Using Newton\u2019s law of universal gravitation: $$ F = \\frac{G M m}{r^2} $$ For circular orbits, the centripetal force required to keep a body in orbit is: $$ F = \\frac{m v^2}{r} $$ Equating the gravitational force to the centripetal force: $$ \\frac{G M m}{r^2} = \\frac{m v^2}{r} $$ Since the orbital velocity $ v $ is related to the orbital period $ T $ by: $$ v = \\frac{2 \\pi r}{T} $$ Substituting $ v $ into the equation: $$ \\frac{G M m}{r^2} = \\frac{m (2 \\pi r)^2}{T^2 r} $$ Simplifying: $$ T^2 = \\frac{4 \\pi^2}{G M} r^3 $$ This confirms Kepler's Third Law: $ T^2 \\propto r^3 $.","title":"Kepler's Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#python-simulation","text":"import numpy as np import matplotlib.pyplot as plt from scipy.constants import G","title":"Python Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#constants","text":"M = 5.972e24 # Mass of Earth (kg) R_Earth = 6.371e6 # Radius of Earth (m)","title":"Constants"},{"location":"1%20Physics/2%20Gravity/Problem_1/#define-function-to-compute-orbital-period","text":"def orbital_period(radius, mass=M): return 2 * np.pi * np.sqrt(radius**3 / (G * mass))","title":"Define function to compute orbital period"},{"location":"1%20Physics/2%20Gravity/Problem_1/#generate-orbital-radii","text":"radii = np.linspace(R_Earth + 200e3, R_Earth + 1e7, 100) # 200 km to 10000 km above Earth periods = orbital_period(radii)","title":"Generate orbital radii"},{"location":"1%20Physics/2%20Gravity/Problem_1/#plot-t2-vs-r3","text":"plt.figure(figsize=(8, 6)) plt.plot(radii 3, periods 2, label=\" \\(T^2 \\propto r^3\\) \", color='b') plt.xlabel(\"Orbital Radius Cubed (m^3)\") plt.ylabel(\"Orbital Period Squared (s^2)\") plt.title(\"Verification of Kepler's Third Law\") plt.legend() plt.grid() plt.show()","title":"Plot T^2 vs. r^3"},{"location":"1%20Physics/2%20Gravity/Problem_1/#implications-and-applications","text":"Kepler\u2019s Third Law allows astronomers to determine planetary masses and distances. It applies to satellites, exoplanets, and even galaxies, aiding in the measurement of cosmic scales. The law extends to elliptical orbits with semi-major axis replacing the circular radius.","title":"Implications and Applications"},{"location":"1%20Physics/2%20Gravity/Problem_1/#conclusion","text":"The relationship \\(T^2 \\propto r^3\\) is fundamental in celestial mechanics. Our simulation verifies this principle, confirming its role in planetary motion and satellite dynamics.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Escape Velocities and Cosmic Velocities Introduction The concept of escape velocity is fundamental in space science, defining the minimum speed needed for an object to break free from a celestial body's gravitational pull. Additionally, the first, second, and third cosmic velocities describe different motion regimes crucial for satellite deployment, interplanetary travel, and interstellar exploration. Definitions First Cosmic Velocity (Orbital Velocity) The minimum velocity required to maintain a stable circular orbit around a celestial body. Given by: $$ v_1 = \\sqrt{\\frac{G M}{r}} $$ Second Cosmic Velocity (Escape Velocity) The velocity needed to completely escape a celestial body's gravitational field. Derived from energy conservation: $$ v_2 = \\sqrt{2} v_1 = \\sqrt{\\frac{2 G M}{r}} $$ Third Cosmic Velocity (Solar System Escape Velocity) The velocity required to escape the Sun\u2019s gravitational influence from a planet. Given by: $$ v_3 = \\sqrt{v_2^2 + v_{esc,sun}^2} $$ Python Simulation import numpy as np import matplotlib.pyplot as plt from scipy.constants import G Constants for celestial bodies (mass in kg, radius in m) \\[ bodies = { \"Earth\": (5.972e24, 6.371e6), \"Mars\": (6.417e23, 3.389e6), \"Jupiter\": (1.898e27, 6.9911e7) } \\] Function to compute velocities def cosmic_velocities(mass, radius): v1 = np.sqrt(G * mass / radius) # Orbital velocity v2 = np.sqrt(2) * v1 # Escape velocity return v1, v2 Compute velocities \\[ velocities = {body: cosmic_velocities(m, r) for body, (m, r) in bodies.items()} \\] Plot results \\[ labels = list(velocities.keys()) vel1 = [velocities[b][0] for b in labels] vel2 = [velocities[b][1] for b in labels] \\] x = np.arange(len(labels)) width = 0.4 plt.figure(figsize=(8, 6)) plt.bar(x - width/2, vel1, width, label=\"Orbital Velocity (m/s)\", color='b') plt.bar(x + width/2, vel2, width, label=\"Escape Velocity (m/s)\", color='r') plt.xlabel(\"Celestial Body\") plt.ylabel(\"Velocity (m/s)\") plt.xticks(x, labels) plt.title(\"Cosmic Velocities for Different Celestial Bodies\") plt.legend() plt.grid() plt.show() Importance in Space Exploration The first cosmic velocity defines satellite launch speeds. The second cosmic velocity determines interplanetary mission requirements. The third cosmic velocity is crucial for interstellar travel considerations. Conclusion Understanding cosmic velocities is essential for space missions, satellite technology, and future interplanetary and interstellar exploration. The provided simulation visualizes these velocities for key celestial bodies, demonstrating their role in space science and engineering.","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#introduction","text":"The concept of escape velocity is fundamental in space science, defining the minimum speed needed for an object to break free from a celestial body's gravitational pull. Additionally, the first, second, and third cosmic velocities describe different motion regimes crucial for satellite deployment, interplanetary travel, and interstellar exploration.","title":"Introduction"},{"location":"1%20Physics/2%20Gravity/Problem_2/#definitions","text":"First Cosmic Velocity (Orbital Velocity) The minimum velocity required to maintain a stable circular orbit around a celestial body. Given by: $$ v_1 = \\sqrt{\\frac{G M}{r}} $$ Second Cosmic Velocity (Escape Velocity) The velocity needed to completely escape a celestial body's gravitational field. Derived from energy conservation: $$ v_2 = \\sqrt{2} v_1 = \\sqrt{\\frac{2 G M}{r}} $$ Third Cosmic Velocity (Solar System Escape Velocity) The velocity required to escape the Sun\u2019s gravitational influence from a planet. Given by: $$ v_3 = \\sqrt{v_2^2 + v_{esc,sun}^2} $$","title":"Definitions"},{"location":"1%20Physics/2%20Gravity/Problem_2/#python-simulation","text":"import numpy as np import matplotlib.pyplot as plt from scipy.constants import G","title":"Python Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#constants-for-celestial-bodies-mass-in-kg-radius-in-m","text":"\\[ bodies = { \"Earth\": (5.972e24, 6.371e6), \"Mars\": (6.417e23, 3.389e6), \"Jupiter\": (1.898e27, 6.9911e7) } \\]","title":"Constants for celestial bodies (mass in kg, radius in m)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#function-to-compute-velocities","text":"def cosmic_velocities(mass, radius): v1 = np.sqrt(G * mass / radius) # Orbital velocity v2 = np.sqrt(2) * v1 # Escape velocity return v1, v2","title":"Function to compute velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#compute-velocities","text":"\\[ velocities = {body: cosmic_velocities(m, r) for body, (m, r) in bodies.items()} \\]","title":"Compute velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#plot-results","text":"\\[ labels = list(velocities.keys()) vel1 = [velocities[b][0] for b in labels] vel2 = [velocities[b][1] for b in labels] \\] x = np.arange(len(labels)) width = 0.4 plt.figure(figsize=(8, 6)) plt.bar(x - width/2, vel1, width, label=\"Orbital Velocity (m/s)\", color='b') plt.bar(x + width/2, vel2, width, label=\"Escape Velocity (m/s)\", color='r') plt.xlabel(\"Celestial Body\") plt.ylabel(\"Velocity (m/s)\") plt.xticks(x, labels) plt.title(\"Cosmic Velocities for Different Celestial Bodies\") plt.legend() plt.grid() plt.show()","title":"Plot results"},{"location":"1%20Physics/2%20Gravity/Problem_2/#importance-in-space-exploration","text":"The first cosmic velocity defines satellite launch speeds. The second cosmic velocity determines interplanetary mission requirements. The third cosmic velocity is crucial for interstellar travel considerations.","title":"Importance in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_2/#conclusion","text":"Understanding cosmic velocities is essential for space missions, satellite technology, and future interplanetary and interstellar exploration. The provided simulation visualizes these velocities for key celestial bodies, demonstrating their role in space science and engineering.","title":"Conclusion"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 Trajectories of a Freely Released Payload Near Earth Introduction When a payload is released from a moving rocket near Earth, its trajectory depends on its initial velocity and altitude. The motion can result in different types of trajectories, such as parabolic, hyperbolic, or elliptical, depending on the payload\u2019s energy. This topic is crucial for satellite deployment, reentry missions, and interplanetary travel planning. Types of Trajectories Elliptical Orbit: If the payload\u2019s velocity is below the escape velocity \\(v_2\\) , it remains in a closed elliptical orbit around Earth. \\(E < 0, \\quad v < v_2\\) Parabolic Trajectory: If the velocity equals the escape velocity \\(v_2\\) , the payload follows a parabolic trajectory and just escapes Earth's gravitational influence. \\(E = 0, \\quad v = v_2\\) Hyperbolic Trajectory: If the velocity exceeds escape velocity, the payload follows a hyperbolic trajectory and leaves Earth\u2019s gravitational field. \\(E > 0, \\quad v > v_2\\) The total energy of the payload is given by: \\(E = \\frac{1}{2} m v^2 - \\frac{G M m}{r}\\) where: - \\(G\\) is the gravitational constant, - \\(M\\) is Earth\u2019s mass, - \\(m\\) is the payload\u2019s mass, - \\(r\\) is the distance from Earth\u2019s center, - \\(v\\) is the velocity of the payload. Python Simulation import numpy as np import matplotlib.pyplot as plt from scipy.constants import G # Constants M = 5.972e24 # Mass of Earth (kg) R_Earth = 6.371e6 # Radius of Earth (m) # Function to compute trajectory def trajectory(v0, theta, t_max=5000, dt=1): r = np.array([R_Earth + 400e3, 0]) # Initial position (400 km altitude) v = np.array([v0 * np.cos(theta), v0 * np.sin(theta)]) trajectory_x, trajectory_y = [r[0]], [r[1]] for _ in range(int(t_max/dt)): r_mag = np.linalg.norm(r) a = -G * M / r_mag**3 * r # Acceleration due to gravity v += a * dt r += v * dt if r_mag < R_Earth: break # Stop if it impacts Earth trajectory_x.append(r[0]) trajectory_y.append(r[1]) return trajectory_x, trajectory_y # Simulate for different initial velocities velocities = [7000, 11200, 14000] # Below orbital, escape, and above escape velocity angles = [np.pi/4] # 45-degree release angle plt.figure(figsize=(10, 8)) for v in velocities: x, y = trajectory(v, angles[0]) plt.plot(x, y, label=f\"v0 = {v} m/s\", linewidth=2) # Plot Earth earth = plt.Circle((0, 0), R_Earth, color='blue', alpha=0.6, label=\"Earth\") plt.gca().add_patch(earth) # Improve visualization plt.xlabel(\"x position (m)\", fontsize=12) plt.ylabel(\"y position (m)\", fontsize=12) plt.title(\"Trajectories of a Freely Released Payload Near Earth\", fontsize=14) plt.legend(fontsize=12) plt.grid(True, linestyle=\"--\", linewidth=0.6) plt.axis('equal') plt.show() Discussion A payload with velocity below escape velocity will stay in orbit or fall back to Earth. At escape velocity, it follows a parabolic trajectory, escaping Earth's gravity. If launched at a speed greater than escape velocity, it will follow a hyperbolic trajectory, leaving Earth permanently. Conclusion Understanding payload trajectories helps in satellite deployment, reentry planning, and deep-space missions. This simulation provides insight into how initial conditions affect motion in Earth's gravitational field.","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#trajectories-of-a-freely-released-payload-near-earth","text":"","title":"Trajectories of a Freely Released Payload Near Earth"},{"location":"1%20Physics/2%20Gravity/Problem_3/#introduction","text":"When a payload is released from a moving rocket near Earth, its trajectory depends on its initial velocity and altitude. The motion can result in different types of trajectories, such as parabolic, hyperbolic, or elliptical, depending on the payload\u2019s energy. This topic is crucial for satellite deployment, reentry missions, and interplanetary travel planning.","title":"Introduction"},{"location":"1%20Physics/2%20Gravity/Problem_3/#types-of-trajectories","text":"Elliptical Orbit: If the payload\u2019s velocity is below the escape velocity \\(v_2\\) , it remains in a closed elliptical orbit around Earth. \\(E < 0, \\quad v < v_2\\) Parabolic Trajectory: If the velocity equals the escape velocity \\(v_2\\) , the payload follows a parabolic trajectory and just escapes Earth's gravitational influence. \\(E = 0, \\quad v = v_2\\) Hyperbolic Trajectory: If the velocity exceeds escape velocity, the payload follows a hyperbolic trajectory and leaves Earth\u2019s gravitational field. \\(E > 0, \\quad v > v_2\\) The total energy of the payload is given by: \\(E = \\frac{1}{2} m v^2 - \\frac{G M m}{r}\\) where: - \\(G\\) is the gravitational constant, - \\(M\\) is Earth\u2019s mass, - \\(m\\) is the payload\u2019s mass, - \\(r\\) is the distance from Earth\u2019s center, - \\(v\\) is the velocity of the payload.","title":"Types of Trajectories"},{"location":"1%20Physics/2%20Gravity/Problem_3/#python-simulation","text":"import numpy as np import matplotlib.pyplot as plt from scipy.constants import G # Constants M = 5.972e24 # Mass of Earth (kg) R_Earth = 6.371e6 # Radius of Earth (m) # Function to compute trajectory def trajectory(v0, theta, t_max=5000, dt=1): r = np.array([R_Earth + 400e3, 0]) # Initial position (400 km altitude) v = np.array([v0 * np.cos(theta), v0 * np.sin(theta)]) trajectory_x, trajectory_y = [r[0]], [r[1]] for _ in range(int(t_max/dt)): r_mag = np.linalg.norm(r) a = -G * M / r_mag**3 * r # Acceleration due to gravity v += a * dt r += v * dt if r_mag < R_Earth: break # Stop if it impacts Earth trajectory_x.append(r[0]) trajectory_y.append(r[1]) return trajectory_x, trajectory_y # Simulate for different initial velocities velocities = [7000, 11200, 14000] # Below orbital, escape, and above escape velocity angles = [np.pi/4] # 45-degree release angle plt.figure(figsize=(10, 8)) for v in velocities: x, y = trajectory(v, angles[0]) plt.plot(x, y, label=f\"v0 = {v} m/s\", linewidth=2) # Plot Earth earth = plt.Circle((0, 0), R_Earth, color='blue', alpha=0.6, label=\"Earth\") plt.gca().add_patch(earth) # Improve visualization plt.xlabel(\"x position (m)\", fontsize=12) plt.ylabel(\"y position (m)\", fontsize=12) plt.title(\"Trajectories of a Freely Released Payload Near Earth\", fontsize=14) plt.legend(fontsize=12) plt.grid(True, linestyle=\"--\", linewidth=0.6) plt.axis('equal') plt.show()","title":"Python Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#discussion","text":"A payload with velocity below escape velocity will stay in orbit or fall back to Earth. At escape velocity, it follows a parabolic trajectory, escaping Earth's gravity. If launched at a speed greater than escape velocity, it will follow a hyperbolic trajectory, leaving Earth permanently.","title":"Discussion"},{"location":"1%20Physics/2%20Gravity/Problem_3/#conclusion","text":"Understanding payload trajectories helps in satellite deployment, reentry planning, and deep-space missions. This simulation provides insight into how initial conditions affect motion in Earth's gravitational field.","title":"Conclusion"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"Problem 1 Waves Interference Patterns on a Water Surface Motivation Interference occurs when waves from different sources overlap and create new patterns. On a water surface, this phenomenon can be easily observed when ripples from different points meet, forming distinct interference patterns. These patterns show how waves combine in different ways, either reinforcing each other (constructive interference) or canceling out (destructive interference). By studying these patterns, we can better understand wave behavior in a simple and visual way. Additionally, it allows us to explore key concepts such as the relationship between wave phase and the effects of multiple sources. This task provides a hands-on approach to learning about wave interactions and their real-world applications, making it an engaging way to explore wave physics. Problem Statement We are tasked with analyzing the interference patterns formed on a water surface due to the superposition of waves emitted from point sources placed at the vertices of a chosen regular polygon. The following steps outline the process: wave equation \\[ \\eta(x,y,t) = \\frac{A}{\\sqrt{r}} \\cdot \\cos{(kr - \\omega t + \\phi)} \\] where: \\(\\eta(x,y,t)\\) is the displacement of the water surface at point \\((x,y)\\) and time \\(t\\) , \\(A\\) is the amplitude of the wave, \\(k = \\frac{2\\pi}{\\lambda}\\) is the wave number, related to the wavelength \\(\\lambda\\) , \\(\\omega = 2\\pi f\\) is the angular frequency, related to the frequency \\(f\\) , \\(r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) is the distance from the source to the point \\((x,y)\\) , \\(\\phi\\) is the initial phase. \"\"\" Steps to Follow: Select a Regular Polygon : Choose a regular polygon (e.g., equilateral triangle, square, or regular pentagon). Position the Sources : Place point wave sources at the vertices of the selected polygon. Wave Equations : Write the equations describing the waves emitted from each source, considering their respective positions. Superposition of Waves : Apply the principle of superposition by summing the wave displacements at each point on the water surface. Analyze Interference Patterns : Examine the resulting displacement as a function of position and time. Identify regions of constructive interference (wave amplification) and destructive interference (wave cancellation). Visualization : Present your findings graphically, illustrating the interference patterns for the chosen regular polygon. Key Considerations: All sources emit waves with the same amplitude \\(A\\) , wavelength \\(\\lambda\\) , and frequency \\(f\\) . The waves are coherent, meaning they maintain a constant phase difference. Use simulation and visualization tools, such as Python with Matplotlib, to aid in the analysis. Mathematical Model A wave emanating from a point source on the water surface can be described by the single disturbance equation : \\[ \\psi(\\vec{r}, t) = A \\cos(k |\\vec{r} - \\vec{r}_0| - \\omega t + \\phi) \\] Where: - \\(\\psi(\\vec{r}, t)\\) is the displacement of the water surface at point \\(\\vec{r}\\) and time \\(t\\) , - \\(A\\) is the amplitude of the wave, - \\(k\\) is the wave number, related to the wavelength \\(\\lambda\\) by \\(k = \\frac{2\\pi}{\\lambda}\\) , - \\(\\omega\\) is the angular frequency, related to the frequency \\(f\\) by \\(\\omega = 2\\pi f\\) , - \\(|\\vec{r} - \\vec{r}_0|\\) is the distance from the source at position $ \\vec{r}_0 $, - \\(\\phi\\) is the initial phase of the wave. Superposition of Waves For multiple sources located at the vertices of a regular polygon, the total displacement at a point \\(\\vec{r}\\) and time \\(t\\) is the sum of the individual displacements from each wave source. The superposition principle states: \\[ \\Psi(\\vec{r}, t) = \\sum_{i=1}^{N} \\psi_i(\\vec{r}, t) \\] Where: - \\(N\\) is the number of sources (the vertices of the polygon), - \\(\\psi_i(\\vec{r}, t)\\) is the displacement from the \\(i\\) -th source. Python Code for Simulating Interference Patterns Below is the Python code that simulates the interference pattern resulting from point sources placed at the vertices of a regular polygon. The code computes the superposition of the waves emitted by these sources and visualizes the resulting interference pattern. Python Script import numpy as np import matplotlib.pyplot as plt # Constants A = 1.0 # Amplitude of the wave k = 2 * np.pi / 1.0 # Wave number (for wavelength \u03bb = 1) omega = 2 * np.pi # Angular frequency (for frequency f = 1) phi = 0 # Initial phase f = 1 # Frequency of the wave t = 0 # Time at which the interference pattern is computed # Define the polygon vertices def polygon_vertices(sides, radius=1): \"\"\"Calculate the vertices of a regular polygon inscribed in a circle.\"\"\" angles = np.linspace(0, 2*np.pi, sides, endpoint=False) return np.array([[radius * np.cos(angle), radius * np.sin(angle)] for angle in angles]) # Wave function at each point (from a single source) def wave(x, y, source, A, k, omega, t, phi): r = np.sqrt((x - source[0])**2 + (y - source[1])**2) return A * np.cos(k * r - omega * t + phi) # Superposition of waves from multiple sources (polygon vertices) def superposition(x, y, sources, A, k, omega, t, phi): total_wave = np.zeros_like(x) for source in sources: total_wave += wave(x, y, source, A, k, omega, t, phi) return total_wave # Create grid of points x = np.linspace(-2, 2, 400) y = np.linspace(-2, 2, 400) X, Y = np.meshgrid(x, y) # Number of sides of the polygon (e.g., 3 for triangle, 4 for square) sides = 4 # Change this for different polygons (3, 5, etc.) sources = polygon_vertices(sides) # Compute the superposition at all grid points Z = superposition(X, Y, sources, A, k, omega, t, phi) . # Plot the interference pattern plt.figure(figsize=(6,6)) plt.contourf(X, Y, Z, 20, cmap='RdGy') plt.colorbar(label='Displacement (\u03c8)') plt.scatter(sources[:,0], sources[:,1], color='black', label='Sources', zorder=5) plt.title(f'Interference Pattern for {sides}-Sided Polygon') plt.xlabel('X') plt.ylabel('Y') plt.legend() plt.show()","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/3%20Waves/Problem_1/#waves-interference-patterns-on-a-water-surface","text":"","title":"Waves Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#motivation","text":"Interference occurs when waves from different sources overlap and create new patterns. On a water surface, this phenomenon can be easily observed when ripples from different points meet, forming distinct interference patterns. These patterns show how waves combine in different ways, either reinforcing each other (constructive interference) or canceling out (destructive interference). By studying these patterns, we can better understand wave behavior in a simple and visual way. Additionally, it allows us to explore key concepts such as the relationship between wave phase and the effects of multiple sources. This task provides a hands-on approach to learning about wave interactions and their real-world applications, making it an engaging way to explore wave physics.","title":"Motivation"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-statement","text":"We are tasked with analyzing the interference patterns formed on a water surface due to the superposition of waves emitted from point sources placed at the vertices of a chosen regular polygon. The following steps outline the process:","title":"Problem Statement"},{"location":"1%20Physics/3%20Waves/Problem_1/#wave-equation","text":"\\[ \\eta(x,y,t) = \\frac{A}{\\sqrt{r}} \\cdot \\cos{(kr - \\omega t + \\phi)} \\] where: \\(\\eta(x,y,t)\\) is the displacement of the water surface at point \\((x,y)\\) and time \\(t\\) , \\(A\\) is the amplitude of the wave, \\(k = \\frac{2\\pi}{\\lambda}\\) is the wave number, related to the wavelength \\(\\lambda\\) , \\(\\omega = 2\\pi f\\) is the angular frequency, related to the frequency \\(f\\) , \\(r = \\sqrt{(x - x_0)^2 + (y - y_0)^2}\\) is the distance from the source to the point \\((x,y)\\) , \\(\\phi\\) is the initial phase. \"\"\"","title":"wave equation"},{"location":"1%20Physics/3%20Waves/Problem_1/#steps-to-follow","text":"Select a Regular Polygon : Choose a regular polygon (e.g., equilateral triangle, square, or regular pentagon). Position the Sources : Place point wave sources at the vertices of the selected polygon. Wave Equations : Write the equations describing the waves emitted from each source, considering their respective positions. Superposition of Waves : Apply the principle of superposition by summing the wave displacements at each point on the water surface. Analyze Interference Patterns : Examine the resulting displacement as a function of position and time. Identify regions of constructive interference (wave amplification) and destructive interference (wave cancellation). Visualization : Present your findings graphically, illustrating the interference patterns for the chosen regular polygon.","title":"Steps to Follow:"},{"location":"1%20Physics/3%20Waves/Problem_1/#key-considerations","text":"All sources emit waves with the same amplitude \\(A\\) , wavelength \\(\\lambda\\) , and frequency \\(f\\) . The waves are coherent, meaning they maintain a constant phase difference. Use simulation and visualization tools, such as Python with Matplotlib, to aid in the analysis.","title":"Key Considerations:"},{"location":"1%20Physics/3%20Waves/Problem_1/#mathematical-model","text":"A wave emanating from a point source on the water surface can be described by the single disturbance equation : \\[ \\psi(\\vec{r}, t) = A \\cos(k |\\vec{r} - \\vec{r}_0| - \\omega t + \\phi) \\] Where: - \\(\\psi(\\vec{r}, t)\\) is the displacement of the water surface at point \\(\\vec{r}\\) and time \\(t\\) , - \\(A\\) is the amplitude of the wave, - \\(k\\) is the wave number, related to the wavelength \\(\\lambda\\) by \\(k = \\frac{2\\pi}{\\lambda}\\) , - \\(\\omega\\) is the angular frequency, related to the frequency \\(f\\) by \\(\\omega = 2\\pi f\\) , - \\(|\\vec{r} - \\vec{r}_0|\\) is the distance from the source at position $ \\vec{r}_0 $, - \\(\\phi\\) is the initial phase of the wave.","title":"Mathematical Model"},{"location":"1%20Physics/3%20Waves/Problem_1/#superposition-of-waves","text":"For multiple sources located at the vertices of a regular polygon, the total displacement at a point \\(\\vec{r}\\) and time \\(t\\) is the sum of the individual displacements from each wave source. The superposition principle states: \\[ \\Psi(\\vec{r}, t) = \\sum_{i=1}^{N} \\psi_i(\\vec{r}, t) \\] Where: - \\(N\\) is the number of sources (the vertices of the polygon), - \\(\\psi_i(\\vec{r}, t)\\) is the displacement from the \\(i\\) -th source.","title":"Superposition of Waves"},{"location":"1%20Physics/3%20Waves/Problem_1/#python-code-for-simulating-interference-patterns","text":"Below is the Python code that simulates the interference pattern resulting from point sources placed at the vertices of a regular polygon. The code computes the superposition of the waves emitted by these sources and visualizes the resulting interference pattern.","title":"Python Code for Simulating Interference Patterns"},{"location":"1%20Physics/3%20Waves/Problem_1/#python-script","text":"import numpy as np import matplotlib.pyplot as plt # Constants A = 1.0 # Amplitude of the wave k = 2 * np.pi / 1.0 # Wave number (for wavelength \u03bb = 1) omega = 2 * np.pi # Angular frequency (for frequency f = 1) phi = 0 # Initial phase f = 1 # Frequency of the wave t = 0 # Time at which the interference pattern is computed # Define the polygon vertices def polygon_vertices(sides, radius=1): \"\"\"Calculate the vertices of a regular polygon inscribed in a circle.\"\"\" angles = np.linspace(0, 2*np.pi, sides, endpoint=False) return np.array([[radius * np.cos(angle), radius * np.sin(angle)] for angle in angles]) # Wave function at each point (from a single source) def wave(x, y, source, A, k, omega, t, phi): r = np.sqrt((x - source[0])**2 + (y - source[1])**2) return A * np.cos(k * r - omega * t + phi) # Superposition of waves from multiple sources (polygon vertices) def superposition(x, y, sources, A, k, omega, t, phi): total_wave = np.zeros_like(x) for source in sources: total_wave += wave(x, y, source, A, k, omega, t, phi) return total_wave # Create grid of points x = np.linspace(-2, 2, 400) y = np.linspace(-2, 2, 400) X, Y = np.meshgrid(x, y) # Number of sides of the polygon (e.g., 3 for triangle, 4 for square) sides = 4 # Change this for different polygons (3, 5, etc.) sources = polygon_vertices(sides) # Compute the superposition at all grid points Z = superposition(X, Y, sources, A, k, omega, t, phi) . # Plot the interference pattern plt.figure(figsize=(6,6)) plt.contourf(X, Y, Z, 20, cmap='RdGy') plt.colorbar(label='Displacement (\u03c8)') plt.scatter(sources[:,0], sources[:,1], color='black', label='Sources', zorder=5) plt.title(f'Interference Pattern for {sides}-Sided Polygon') plt.xlabel('X') plt.ylabel('Y') plt.legend() plt.show()","title":"Python Script"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Problem 1 %%markdown Simulating the Effects of the Lorentz Force Motivation The Lorentz force governs the motion of charged particles in electric and magnetic fields. It is given by: \\[\\mathbf{F} = q (\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B})\\] where: - \\(q\\) is the charge of the particle, - \\(\\mathbf{E}\\) is the electric field, - \\(\\mathbf{B}\\) is the magnetic field, - \\(\\mathbf{v}\\) is the velocity of the particle. This force plays a crucial role in various physical systems such as: - Particle accelerators - Mass spectrometers - Plasma confinement (Tokamaks, Stellarators) By simulating the motion of charged particles, we can better understand the practical applications and visualize their trajectories. 1. Equations of Motion Using Newton\u2019s second law: \\[m \\frac{d\\mathbf{v}}{dt} = q (\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B})\\] Expanding this into components: \\(m \\frac{dv_x}{dt} = q (E_x + v_y B_z - v_z B_y)\\) \\(m \\frac{dv_y}{dt} = q (E_y + v_z B_x - v_x B_z)\\) \\(m \\frac{dv_z}{dt} = q (E_z + v_x B_y - v_y B_x)\\) We numerically solve these equations using the Runge-Kutta or Euler method. 2. Implementation in Python import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants q = 1.6e-19 # Charge (Coulombs) m = 9.11e-31 # Mass (kg) B = np.array([0, 0, 1]) # Uniform magnetic field in z-direction (Tesla) E = np.array([0, 0, 0]) # Electric field (V/m) # Equations of motion def lorentz_force(t, y): x, y, z, vx, vy, vz = y v = np.array([vx, vy, vz]) dvdt = (q/m) * (E + np.cross(v, B)) return [vx, vy, vz, dvdt[0], dvdt[1], dvdt[2]] # Initial conditions x0, y0, z0 = 0, 0, 0 vx0, vy0, vz0 = 1e6, 0, 0 # Initial velocity (m/s) y0 = [x0, y0, z0, vx0, vy0, vz0] # Time range t_span = (0, 1e-6) t_eval = np.linspace(*t_span, 1000) # Solve ODEs sol = solve_ivp(lorentz_force, t_span, y0, t_eval=t_eval, method='RK45') # Extract solutions x, y, z = sol.y[0], sol.y[1], sol.y[2] # Plot trajectory fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot(x, y, z, label='Particle Trajectory') ax.set_xlabel('X (m)') ax.set_ylabel('Y (m)') ax.set_zlabel('Z (m)') ax.set_title('Motion of a Charged Particle in a Magnetic Field') ax.legend() plt.show() 3. Results and Observations The particle undergoes a circular motion due to the Lorentz force in a uniform magnetic field. When both \\(\\mathbf{E}\\) and \\(\\mathbf{B}\\) fields are present, the motion can become helical or exhibit an E\u00d7B drift . The Larmor radius (radius of circular motion) is given by: \\( \\(r_L = \\frac{m v_\\perp}{q B}\\) \\) where \\(v_\\perp\\) is the velocity perpendicular to \\(\\mathbf{B}\\) . 4. Extensions and Further Work Adding a non-uniform magnetic field to simulate more realistic systems like a Tokamak. Introducing time-dependent electric fields. Investigating relativistic effects at high velocities. This simulation provides insights into the fundamental principles governing charged particle motion and their applications in physics and engineering.","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#problem-1","text":"%%markdown","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulating-the-effects-of-the-lorentz-force","text":"","title":"Simulating the Effects of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#motivation","text":"The Lorentz force governs the motion of charged particles in electric and magnetic fields. It is given by: \\[\\mathbf{F} = q (\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B})\\] where: - \\(q\\) is the charge of the particle, - \\(\\mathbf{E}\\) is the electric field, - \\(\\mathbf{B}\\) is the magnetic field, - \\(\\mathbf{v}\\) is the velocity of the particle. This force plays a crucial role in various physical systems such as: - Particle accelerators - Mass spectrometers - Plasma confinement (Tokamaks, Stellarators) By simulating the motion of charged particles, we can better understand the practical applications and visualize their trajectories.","title":"Motivation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#1-equations-of-motion","text":"Using Newton\u2019s second law: \\[m \\frac{d\\mathbf{v}}{dt} = q (\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B})\\] Expanding this into components: \\(m \\frac{dv_x}{dt} = q (E_x + v_y B_z - v_z B_y)\\) \\(m \\frac{dv_y}{dt} = q (E_y + v_z B_x - v_x B_z)\\) \\(m \\frac{dv_z}{dt} = q (E_z + v_x B_y - v_y B_x)\\) We numerically solve these equations using the Runge-Kutta or Euler method.","title":"1. Equations of Motion"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#2-implementation-in-python","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Constants q = 1.6e-19 # Charge (Coulombs) m = 9.11e-31 # Mass (kg) B = np.array([0, 0, 1]) # Uniform magnetic field in z-direction (Tesla) E = np.array([0, 0, 0]) # Electric field (V/m) # Equations of motion def lorentz_force(t, y): x, y, z, vx, vy, vz = y v = np.array([vx, vy, vz]) dvdt = (q/m) * (E + np.cross(v, B)) return [vx, vy, vz, dvdt[0], dvdt[1], dvdt[2]] # Initial conditions x0, y0, z0 = 0, 0, 0 vx0, vy0, vz0 = 1e6, 0, 0 # Initial velocity (m/s) y0 = [x0, y0, z0, vx0, vy0, vz0] # Time range t_span = (0, 1e-6) t_eval = np.linspace(*t_span, 1000) # Solve ODEs sol = solve_ivp(lorentz_force, t_span, y0, t_eval=t_eval, method='RK45') # Extract solutions x, y, z = sol.y[0], sol.y[1], sol.y[2] # Plot trajectory fig = plt.figure(figsize=(8, 6)) ax = fig.add_subplot(111, projection='3d') ax.plot(x, y, z, label='Particle Trajectory') ax.set_xlabel('X (m)') ax.set_ylabel('Y (m)') ax.set_zlabel('Z (m)') ax.set_title('Motion of a Charged Particle in a Magnetic Field') ax.legend() plt.show()","title":"2. Implementation in Python"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#3-results-and-observations","text":"The particle undergoes a circular motion due to the Lorentz force in a uniform magnetic field. When both \\(\\mathbf{E}\\) and \\(\\mathbf{B}\\) fields are present, the motion can become helical or exhibit an E\u00d7B drift . The Larmor radius (radius of circular motion) is given by: \\( \\(r_L = \\frac{m v_\\perp}{q B}\\) \\) where \\(v_\\perp\\) is the velocity perpendicular to \\(\\mathbf{B}\\) .","title":"3. Results and Observations"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#4-extensions-and-further-work","text":"Adding a non-uniform magnetic field to simulate more realistic systems like a Tokamak. Introducing time-dependent electric fields. Investigating relativistic effects at high velocities. This simulation provides insights into the fundamental principles governing charged particle motion and their applications in physics and engineering.","title":"4. Extensions and Further Work"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1 Equivalent Resistance Using Graph Theory Motivation The calculation of equivalent resistance is a fundamental problem in electrical circuits and is crucial for understanding and designing efficient systems. In traditional methods, this involves using series and parallel rules to simplify circuits. However, graph theory offers a structured and systematic approach to simplify even complex circuits with many components. Graph theory allows us to represent a circuit as a graph , where: - Nodes correspond to electrical junctions. - Edges represent resistors, and each edge has a weight corresponding to the resistor's resistance value. Mathematical Background In electrical circuits, the equivalent resistance depends on how resistors are connected: Series Connection When resistors are connected in series, the total or equivalent resistance \\(R_{\\text{eq}}\\) is the sum of the individual resistances: \\(R_{\\text{eq}} = R_1 + R_2 + R_3 + \\dots + R_n\\) Where: - \\(R_1, R_2, R_3, \\dots, R_n\\) are the resistances of the individual resistors. Parallel Connection For resistors connected in parallel, the equivalent resistance is given by: \\(\\frac{1}{R_{\\text{eq}}} = \\frac{1}{R_1} + \\frac{1}{R_2} + \\frac{1}{R_3} + \\dots + \\frac{1}{R_n}\\) Where: - \\(R_1, R_2, R_3, \\dots, R_n\\) are the resistances of the individual resistors. Alternatively, for two resistors \\(R_1\\) and \\(R_2\\) in parallel, the equivalent resistance \\(R_{\\text{eq}}\\) is: \\(R_{\\text{eq}} = \\frac{R_1 R_2}{R_1 + R_2}\\) Graph Representation We can model the circuit as a graph where: - Nodes represent junctions in the circuit. - Edges represent the resistors between these junctions. - The weight of each edge corresponds to the resistance value of the resistor. Algorithm Description Step 1: Identify Series and Parallel Connections Series Connection : Identify resistors that are in series (connected end-to-end) and compute their equivalent resistance. Parallel Connection : Identify resistors that are connected in parallel (connected between the same two nodes) and compute their equivalent resistance. Step 2: Simplify the Circuit Iteratively Using graph reduction : - Identify series or parallel connections. - Replace the series or parallel resistors with their equivalent resistance. - Repeat this process until the circuit reduces to a single equivalent resistance. Pseudocode Python Implementation Step 1: Import Libraries import networkx as nx import numpy as np import matplotlib.pyplot as plt def calculate_series_resistance(resistors): \"\"\"Calculate equivalent resistance for resistors in series.\"\"\" return sum(resistors) def calculate_parallel_resistance(resistors): \"\"\"Calculate equivalent resistance for resistors in parallel.\"\"\" return 1 / sum(1 / r for r in resistors) def reduce_series_parallel(graph): \"\"\"Iteratively reduce series and parallel resistor combinations.\"\"\" while len(graph.nodes) > 1: # Identify all series connections for node in list(graph.nodes): neighbors = list(graph.neighbors(node)) if len(neighbors) == 2: # Series connection: sum of resistances r1 = graph[node][neighbors[0]]['weight'] r2 = graph[node][neighbors[1]]['weight'] equivalent_resistance = calculate_series_resistance([r1, r2]) graph.add_edge(neighbors[0], neighbors[1], weight=equivalent_resistance) graph.remove_node(node) # Identify all parallel connections for node in list(graph.nodes): neighbors = list(graph.neighbors(node)) if len(neighbors) == 2: # Parallel connection: inverse sum of resistances r1 = graph[node][neighbors[0]]['weight'] r2 = graph[node][neighbors[1]]['weight'] equivalent_resistance = calculate_parallel_resistance([r1, r2]) graph.add_edge(neighbors[0], neighbors[1], weight=equivalent_resistance) graph.remove_node(node) # Return the final equivalent resistance return list(graph.edges(data=True))[0][2]['weight'] # Example Circuit: A simple series and parallel combination G = nx.Graph() G.add_edge(1, 2, weight=10) # R1 = 10 Ohms G.add_edge(2, 3, weight=20) # R2 = 20 Ohms G.add_edge(1, 3, weight=30) # R3 = 30 Ohms (parallel combination) # Calculate the equivalent resistance R_eq = reduce_series_parallel(G) print(f\"The equivalent resistance of the circuit is: {R_eq} Ohms\") ### Key Details in this Markdown: 1. **Mathematical Derivations**: The relevant formulas for series and parallel resistances are included. 2. **Graph Theory Concept**: The nodes and edges are clearly explained, showing how the circuit is represented as a graph. 3. **Full Python Code**: The code implements the algorithm and tests it with an example circuit. 4. **Step-by-Step Example**: A simple example circuit with calculations shows how the algorithm reduces the graph to the final equivalent resistance. 5. **Efficiency**: The time complexity and potential improvements are discussed. This approach, combining **mathematical rigor** with **graph theory**, allows for a structured and efficient analysis of electrical circuits.","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#equivalent-resistance-using-graph-theory","text":"","title":"Equivalent Resistance Using Graph Theory"},{"location":"1%20Physics/5%20Circuits/Problem_1/#motivation","text":"The calculation of equivalent resistance is a fundamental problem in electrical circuits and is crucial for understanding and designing efficient systems. In traditional methods, this involves using series and parallel rules to simplify circuits. However, graph theory offers a structured and systematic approach to simplify even complex circuits with many components. Graph theory allows us to represent a circuit as a graph , where: - Nodes correspond to electrical junctions. - Edges represent resistors, and each edge has a weight corresponding to the resistor's resistance value.","title":"Motivation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#mathematical-background","text":"In electrical circuits, the equivalent resistance depends on how resistors are connected:","title":"Mathematical Background"},{"location":"1%20Physics/5%20Circuits/Problem_1/#series-connection","text":"When resistors are connected in series, the total or equivalent resistance \\(R_{\\text{eq}}\\) is the sum of the individual resistances: \\(R_{\\text{eq}} = R_1 + R_2 + R_3 + \\dots + R_n\\) Where: - \\(R_1, R_2, R_3, \\dots, R_n\\) are the resistances of the individual resistors.","title":"Series Connection"},{"location":"1%20Physics/5%20Circuits/Problem_1/#parallel-connection","text":"For resistors connected in parallel, the equivalent resistance is given by: \\(\\frac{1}{R_{\\text{eq}}} = \\frac{1}{R_1} + \\frac{1}{R_2} + \\frac{1}{R_3} + \\dots + \\frac{1}{R_n}\\) Where: - \\(R_1, R_2, R_3, \\dots, R_n\\) are the resistances of the individual resistors. Alternatively, for two resistors \\(R_1\\) and \\(R_2\\) in parallel, the equivalent resistance \\(R_{\\text{eq}}\\) is: \\(R_{\\text{eq}} = \\frac{R_1 R_2}{R_1 + R_2}\\)","title":"Parallel Connection"},{"location":"1%20Physics/5%20Circuits/Problem_1/#graph-representation","text":"We can model the circuit as a graph where: - Nodes represent junctions in the circuit. - Edges represent the resistors between these junctions. - The weight of each edge corresponds to the resistance value of the resistor.","title":"Graph Representation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#algorithm-description","text":"","title":"Algorithm Description"},{"location":"1%20Physics/5%20Circuits/Problem_1/#step-1-identify-series-and-parallel-connections","text":"Series Connection : Identify resistors that are in series (connected end-to-end) and compute their equivalent resistance. Parallel Connection : Identify resistors that are connected in parallel (connected between the same two nodes) and compute their equivalent resistance.","title":"Step 1: Identify Series and Parallel Connections"},{"location":"1%20Physics/5%20Circuits/Problem_1/#step-2-simplify-the-circuit-iteratively","text":"Using graph reduction : - Identify series or parallel connections. - Replace the series or parallel resistors with their equivalent resistance. - Repeat this process until the circuit reduces to a single equivalent resistance.","title":"Step 2: Simplify the Circuit Iteratively"},{"location":"1%20Physics/5%20Circuits/Problem_1/#pseudocode","text":"","title":"Pseudocode"},{"location":"1%20Physics/5%20Circuits/Problem_1/#python-implementation","text":"","title":"Python Implementation"},{"location":"1%20Physics/5%20Circuits/Problem_1/#step-1-import-libraries","text":"import networkx as nx import numpy as np import matplotlib.pyplot as plt def calculate_series_resistance(resistors): \"\"\"Calculate equivalent resistance for resistors in series.\"\"\" return sum(resistors) def calculate_parallel_resistance(resistors): \"\"\"Calculate equivalent resistance for resistors in parallel.\"\"\" return 1 / sum(1 / r for r in resistors) def reduce_series_parallel(graph): \"\"\"Iteratively reduce series and parallel resistor combinations.\"\"\" while len(graph.nodes) > 1: # Identify all series connections for node in list(graph.nodes): neighbors = list(graph.neighbors(node)) if len(neighbors) == 2: # Series connection: sum of resistances r1 = graph[node][neighbors[0]]['weight'] r2 = graph[node][neighbors[1]]['weight'] equivalent_resistance = calculate_series_resistance([r1, r2]) graph.add_edge(neighbors[0], neighbors[1], weight=equivalent_resistance) graph.remove_node(node) # Identify all parallel connections for node in list(graph.nodes): neighbors = list(graph.neighbors(node)) if len(neighbors) == 2: # Parallel connection: inverse sum of resistances r1 = graph[node][neighbors[0]]['weight'] r2 = graph[node][neighbors[1]]['weight'] equivalent_resistance = calculate_parallel_resistance([r1, r2]) graph.add_edge(neighbors[0], neighbors[1], weight=equivalent_resistance) graph.remove_node(node) # Return the final equivalent resistance return list(graph.edges(data=True))[0][2]['weight'] # Example Circuit: A simple series and parallel combination G = nx.Graph() G.add_edge(1, 2, weight=10) # R1 = 10 Ohms G.add_edge(2, 3, weight=20) # R2 = 20 Ohms G.add_edge(1, 3, weight=30) # R3 = 30 Ohms (parallel combination) # Calculate the equivalent resistance R_eq = reduce_series_parallel(G) print(f\"The equivalent resistance of the circuit is: {R_eq} Ohms\") ### Key Details in this Markdown: 1. **Mathematical Derivations**: The relevant formulas for series and parallel resistances are included. 2. **Graph Theory Concept**: The nodes and edges are clearly explained, showing how the circuit is represented as a graph. 3. **Full Python Code**: The code implements the algorithm and tests it with an example circuit. 4. **Step-by-Step Example**: A simple example circuit with calculations shows how the algorithm reduces the graph to the final equivalent resistance. 5. **Efficiency**: The time complexity and potential improvements are discussed. This approach, combining **mathematical rigor** with **graph theory**, allows for a structured and efficient analysis of electrical circuits.","title":"Step 1: Import Libraries"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1 Motivation: The Central Limit Theorem (CLT) is a fundamental result in statistics that states the following: \"The sampling distribution of the sample mean will tend to follow a normal distribution as the sample size increases, regardless of the shape of the original population distribution.\" This means that even if the underlying population is not normally distributed, if we take sufficiently large random samples and compute the sample mean, the distribution of the sample means will converge to a normal distribution as the sample size increases. Mathematically, let X\u2081, X\u2082, ..., X\u2099 be i.i.d. (independent and identically distributed) random variables with a population mean \u03bc and variance \u03c3\u00b2. Then the sample mean: X\u0304\u2099 = (1/n) * \u03a3 X\u1d62 follows: X\u0304\u2099 ~ N(\u03bc, \u03c3\u00b2/n) approximately, as n \u2192 \u221e This theorem holds true regardless of the original population distribution (e.g., Uniform, Exponential, Binomial). By simulating different population distributions and calculating sample means, we can observe the CLT in action. Population size (large enough to approximate the \"true\" population) population_size = 100000 Generate different population distributions uniform_population = np.random.uniform(low=0, high=1, size=population_size) exponential_population = np.random.exponential(scale=1.0, size=population_size) binomial_population = np.random.binomial(n=10, p=0.5, size=population_size) Sample sizes to test CLT convergence sample_sizes = [5, 10, 30, 50] Number of samples to draw for each sample size n_samples = 1000 Function to compute sample means def compute_sample_means(population, sample_size, n_samples): \"\"\" Draws multiple samples from a population and computes the sample means. Parameters: population (array): the full population data sample_size (int): size of each sample n_samples (int): number of samples to draw Returns: np.array: array of sample means \"\"\" sample_means = [] for _ in range(n_samples): sample = np.random.choice(population, size=sample_size, replace=False) sample_mean = np.mean(sample) sample_means.append(sample_mean) return np.array(sample_means) Dictionary of distributions to analyze distributions = { \"Uniform(0,1)\": uniform_population, \"Exponential(\u03bb=1)\": exponential_population, \"Binomial(n=10, p=0.5)\": binomial_population } Visualization of sample mean distributions for dist_name, population in distributions.items(): plt.figure(figsize=(14, 10)) for i, size in enumerate(sample_sizes): means = compute_sample_means(population, sample_size=size, n_samples=n_samples) plt.subplot(2, 2, i + 1) sns.histplot(means, kde=True, bins=30, color='steelblue') plt.title(f'{dist_name} - Sample Size = {size}') plt.xlabel('Sample Mean') plt.ylabel('Frequency') # Empirical mean and variance of the sampling distribution empirical_mean = np.mean(means) empirical_std = np.std(means) # True population parameters pop_mean = np.mean(population) pop_var = np.var(population) # Theoretical standard deviation of the sample mean # \u03c3/\u221an theoretical_std = np.sqrt(pop_var / size) print(f\"Distribution: {dist_name} | Sample Size: {size}\") print(f\" Population Mean (\u03bc): {pop_mean:.4f}\") print(f\" Population Variance (\u03c3\u00b2): {pop_var:.4f}\") print(f\" Empirical Mean of X\u0304: {empirical_mean:.4f}\") print(f\" Empirical Std of X\u0304: {empirical_std:.4f}\") print(f\" Theoretical Std of X\u0304: {theoretical_std:.4f}\") print(\"-\" * 60) plt.suptitle(f'Sampling Distribution of the Mean \u2014 {dist_name}', fontsize=16) plt.tight_layout(rect=[0, 0.03, 1, 0.95]) plt.show() CLT Summary: Regardless of the original population distribution (uniform, skewed, discrete), as the sample size increases, the distribution of the sample mean approaches a normal distribution: X\u0304\u2099 \u2248 N(\u03bc, \u03c3\u00b2/n) Key observations from simulation: With small sample sizes (e.g., n=5), the shape of the population is still visible. At n=30 or greater, all distributions begin to look approximately normal. The variance of the sample mean decreases as sample size increases.","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#motivation","text":"The Central Limit Theorem (CLT) is a fundamental result in statistics that","title":"Motivation:"},{"location":"1%20Physics/6%20Statistics/Problem_1/#states-the-following","text":"\"The sampling distribution of the sample mean will tend to follow a normal distribution as the sample size increases, regardless of the shape of the original population distribution.\"","title":"states the following:"},{"location":"1%20Physics/6%20Statistics/Problem_1/#_1","text":"This means that even if the underlying population is not normally distributed, if we take sufficiently large random samples and compute the sample mean, the distribution of the sample means will converge to a normal distribution as the sample size increases.","title":""},{"location":"1%20Physics/6%20Statistics/Problem_1/#_2","text":"Mathematically, let X\u2081, X\u2082, ..., X\u2099 be i.i.d. (independent and identically distributed) random variables with a population mean \u03bc and variance \u03c3\u00b2. Then the sample mean: X\u0304\u2099 = (1/n) * \u03a3 X\u1d62 follows: X\u0304\u2099 ~ N(\u03bc, \u03c3\u00b2/n) approximately, as n \u2192 \u221e This theorem holds true regardless of the original population distribution (e.g., Uniform, Exponential, Binomial).","title":""},{"location":"1%20Physics/6%20Statistics/Problem_1/#by-simulating-different-population-distributions-and-calculating-sample-means-we-can-observe-the-clt-in-action","text":"Population size (large enough to approximate the \"true\" population) population_size = 100000","title":"By simulating different population distributions and calculating sample means, we can observe the CLT in action."},{"location":"1%20Physics/6%20Statistics/Problem_1/#generate-different-population-distributions","text":"uniform_population = np.random.uniform(low=0, high=1, size=population_size) exponential_population = np.random.exponential(scale=1.0, size=population_size) binomial_population = np.random.binomial(n=10, p=0.5, size=population_size)","title":"Generate different population distributions"},{"location":"1%20Physics/6%20Statistics/Problem_1/#sample-sizes-to-test-clt-convergence","text":"sample_sizes = [5, 10, 30, 50]","title":"Sample sizes to test CLT convergence"},{"location":"1%20Physics/6%20Statistics/Problem_1/#number-of-samples-to-draw-for-each-sample-size","text":"n_samples = 1000","title":"Number of samples to draw for each sample size"},{"location":"1%20Physics/6%20Statistics/Problem_1/#function-to-compute-sample-means","text":"def compute_sample_means(population, sample_size, n_samples): \"\"\" Draws multiple samples from a population and computes the sample means. Parameters: population (array): the full population data sample_size (int): size of each sample n_samples (int): number of samples to draw Returns: np.array: array of sample means \"\"\" sample_means = [] for _ in range(n_samples): sample = np.random.choice(population, size=sample_size, replace=False) sample_mean = np.mean(sample) sample_means.append(sample_mean) return np.array(sample_means)","title":"Function to compute sample means"},{"location":"1%20Physics/6%20Statistics/Problem_1/#dictionary-of-distributions-to-analyze","text":"distributions = { \"Uniform(0,1)\": uniform_population, \"Exponential(\u03bb=1)\": exponential_population, \"Binomial(n=10, p=0.5)\": binomial_population }","title":"Dictionary of distributions to analyze"},{"location":"1%20Physics/6%20Statistics/Problem_1/#visualization-of-sample-mean-distributions","text":"for dist_name, population in distributions.items(): plt.figure(figsize=(14, 10)) for i, size in enumerate(sample_sizes): means = compute_sample_means(population, sample_size=size, n_samples=n_samples) plt.subplot(2, 2, i + 1) sns.histplot(means, kde=True, bins=30, color='steelblue') plt.title(f'{dist_name} - Sample Size = {size}') plt.xlabel('Sample Mean') plt.ylabel('Frequency') # Empirical mean and variance of the sampling distribution empirical_mean = np.mean(means) empirical_std = np.std(means) # True population parameters pop_mean = np.mean(population) pop_var = np.var(population) # Theoretical standard deviation of the sample mean # \u03c3/\u221an theoretical_std = np.sqrt(pop_var / size) print(f\"Distribution: {dist_name} | Sample Size: {size}\") print(f\" Population Mean (\u03bc): {pop_mean:.4f}\") print(f\" Population Variance (\u03c3\u00b2): {pop_var:.4f}\") print(f\" Empirical Mean of X\u0304: {empirical_mean:.4f}\") print(f\" Empirical Std of X\u0304: {empirical_std:.4f}\") print(f\" Theoretical Std of X\u0304: {theoretical_std:.4f}\") print(\"-\" * 60) plt.suptitle(f'Sampling Distribution of the Mean \u2014 {dist_name}', fontsize=16) plt.tight_layout(rect=[0, 0.03, 1, 0.95]) plt.show()","title":"Visualization of sample mean distributions"},{"location":"1%20Physics/6%20Statistics/Problem_1/#clt-summary","text":"","title":"CLT Summary:"},{"location":"1%20Physics/6%20Statistics/Problem_1/#_3","text":"Regardless of the original population distribution (uniform, skewed, discrete), as the sample size increases, the distribution of the sample mean approaches","title":""},{"location":"1%20Physics/6%20Statistics/Problem_1/#a-normal-distribution","text":"","title":"a normal distribution:"},{"location":"1%20Physics/6%20Statistics/Problem_1/#_4","text":"X\u0304\u2099 \u2248 N(\u03bc, \u03c3\u00b2/n)","title":""},{"location":"1%20Physics/6%20Statistics/Problem_1/#_5","text":"","title":""},{"location":"1%20Physics/6%20Statistics/Problem_1/#key-observations-from-simulation","text":"With small sample sizes (e.g., n=5), the shape of the population is still visible. At n=30 or greater, all distributions begin to look approximately normal. The variance of the sample mean decreases as sample size increases.","title":"Key observations from simulation:"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2 Estimating \\(\\pi\\) Using Monte Carlo Methods Motivation: Monte Carlo simulations are a powerful class of computational techniques that use randomness to solve problems or estimate values. One of the most elegant applications of Monte Carlo methods is estimating the value of \\(\\pi\\) through geometric probability. By randomly generating points and analyzing their positions relative to a geometric shape, we can approximate \\(\\pi\\) in an intuitive and visually engaging way. This problem connects fundamental concepts of probability, geometry, and numerical computation. It also provides a gateway to understanding how randomness can be harnessed to solve complex problems in physics, finance, and computer science. The Monte Carlo approach to \\(\\pi\\) estimation highlights the versatility and simplicity of this method while offering practical insights into convergence rates and computational efficiency. Part 1: Estimating \\(\\pi\\) Using a Circle 1. Theoretical Foundation: The ratio of points inside a circle to the total number of points in a square can be used to estimate \\(\\pi\\) . A unit circle with radius \\(r = 1\\) is inscribed within a square with side length 2. The area of the circle is \\(A_{\\text{circle}} = \\pi r^2\\) , which simplifies to \\(\\pi\\) for \\(r = 1\\) . The area of the square is \\(A_{\\text{square}} = 2 \\times 2 = 4\\) . The ratio of points inside the circle to the total points can be used to approximate \\(\\pi\\) : \\(\\pi = 4 \\times \\frac{N_{\\text{inside}}}{N_{\\text{total}}}\\) Where: - \\(N_{\\text{inside}}\\) is the number of points inside the circle. - \\(N_{\\text{total}}\\) is the total number of points generated in the square. 2. Simulation: Generate random points within a square with dimensions from -1 to 1 in both \\(x\\) and \\(y\\) directions. Check whether each point lies inside the unit circle by testing if: \\(x^2 + y^2 \\leq 1\\) If true, the point is inside the circle. 3. Visualization: Create a plot showing the random points in the square. Points inside the circle will be shown in one color, and points outside will be in another color. Display the circle and square for clarity. 4. Analysis: Investigate how the accuracy of the estimate improves as the number of points increases. Discuss the convergence rate and computational considerations for this method. Part 2: Estimating $ \\pi $ Using Buffon\u2019s Needle 1. Theoretical Foundation: The Buffon\u2019s Needle problem involves dropping a needle of length \\(L\\) onto a plane with parallel lines spaced a distance \\(D\\) apart. The probability of the needle crossing a line depends on the angle of the needle and its distance to the nearest line. The formula for estimating \\(\\pi\\) based on this probability is: \\(\\pi = \\frac{2L N_{\\text{drops}}}{D N_{\\text{crosses}}}\\) Where: - \\(L\\) is the length of the needle. - \\(D\\) is the distance between the parallel lines. - \\(N_{\\text{crosses}}\\) is the number of times the needle crosses a line. - \\(N_{\\text{drops}}\\) is the total number of needle drops. 2. Simulation: Simulate the random dropping of a needle onto a plane with parallel lines. For each drop, calculate the distance from the needle\u2019s midpoint to the nearest line and the angle of the needle. Determine whether the needle crosses a line based on the geometric conditions. 3. Visualization: Create a graphical representation of the simulation. Show the positions of the needles and whether they cross a line or not. 4. Analysis: Explore how the number of needle drops affects the estimate\u2019s accuracy. Compare the convergence rate of this method to the circle-based approach. 3. Python Code for Circle-Based Method: import numpy as np import matplotlib.pyplot as plt # Function to estimate \u03c0 using Monte Carlo method based on circle def estimate_pi_circle(n_points): # Generate random points (x, y) in the square [-1, 1] x [-1, 1] x = np.random.uniform(-1, 1, n_points) y = np.random.uniform(-1, 1, n_points) # Calculate the distance of each point from the origin (x^2 + y^2) distance_squared = x**2 + y**2 # Count the points inside the unit circle (x^2 + y^2 <= 1) points_inside_circle = np.sum(distance_squared <= 1) # Estimate \u03c0 using the ratio of points inside the circle # \u03c0 = 4 * (points inside circle) / (total points) pi_estimate = 4 * points_inside_circle / n_points return pi_estimate, x, y, distance_squared <= 1 # Run the simulation for 10,000 points n_points = 10000 pi_estimate, x, y, inside_circle = estimate_pi_circle(n_points) # Visualize the points and the circle plt.figure(figsize=(6,6)) plt.scatter(x[inside_circle], y[inside_circle], color='green', s=1, label='Inside Circle') plt.scatter(x[~inside_circle], y[~inside_circle], color='red', s=1, label='Outside Circle') plt.gca().set_aspect('equal', adjustable='box') plt.title(f\"Monte Carlo Estimation of $\\\\pi$\\nEstimated $\\\\pi$: {pi_estimate:.4f}\") plt.xlabel('X') plt.ylabel('Y') plt.legend() plt.grid(True) plt.show() Function to simulate Buffon's Needle def estimate_pi_buffon(needle_length, line_distance, n_drops): crosses = 0 for _ in range(n_drops): # Randomly generate the distance from the needle's midpoint to the nearest line dist_to_line = np.random.uniform(0, line_distance / 2) # Randomly generate the angle of the needle (uniformly between 0 and \u03c0/2) angle = np.random.uniform(0, np.pi / 2) # Check if the needle crosses the line if dist_to_line <= (needle_length / 2) * np.sin(angle): crosses += 1 # Estimate \u03c0 using Buffon's Needle formula pi_estimate = (2 * needle_length * n_drops) / (line_distance * crosses) return pi_estimate Run the simulation for Buffon's Needle needle_length = 1 # length of the needle (L) line_distance = 2 # distance between parallel lines (D) n_drops = 10000 # number of needle drops (N_drops) Estimate \u03c0 using Buffon's Needle method pi_estimate_buffon = estimate_pi_buffon(needle_length, line_distance, n_drops) print(f\"Estimated \u03c0 using Buffon's Needle: {pi_estimate_buffon:.4f}\")","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#estimating-pi-using-monte-carlo-methods","text":"","title":"Estimating \\(\\pi\\) Using Monte Carlo Methods"},{"location":"1%20Physics/6%20Statistics/Problem_2/#motivation","text":"Monte Carlo simulations are a powerful class of computational techniques that use randomness to solve problems or estimate values. One of the most elegant applications of Monte Carlo methods is estimating the value of \\(\\pi\\) through geometric probability. By randomly generating points and analyzing their positions relative to a geometric shape, we can approximate \\(\\pi\\) in an intuitive and visually engaging way. This problem connects fundamental concepts of probability, geometry, and numerical computation. It also provides a gateway to understanding how randomness can be harnessed to solve complex problems in physics, finance, and computer science. The Monte Carlo approach to \\(\\pi\\) estimation highlights the versatility and simplicity of this method while offering practical insights into convergence rates and computational efficiency.","title":"Motivation:"},{"location":"1%20Physics/6%20Statistics/Problem_2/#part-1-estimating-pi-using-a-circle","text":"","title":"Part 1: Estimating \\(\\pi\\) Using a Circle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#1-theoretical-foundation","text":"The ratio of points inside a circle to the total number of points in a square can be used to estimate \\(\\pi\\) . A unit circle with radius \\(r = 1\\) is inscribed within a square with side length 2. The area of the circle is \\(A_{\\text{circle}} = \\pi r^2\\) , which simplifies to \\(\\pi\\) for \\(r = 1\\) . The area of the square is \\(A_{\\text{square}} = 2 \\times 2 = 4\\) . The ratio of points inside the circle to the total points can be used to approximate \\(\\pi\\) : \\(\\pi = 4 \\times \\frac{N_{\\text{inside}}}{N_{\\text{total}}}\\) Where: - \\(N_{\\text{inside}}\\) is the number of points inside the circle. - \\(N_{\\text{total}}\\) is the total number of points generated in the square.","title":"1. Theoretical Foundation:"},{"location":"1%20Physics/6%20Statistics/Problem_2/#2-simulation","text":"Generate random points within a square with dimensions from -1 to 1 in both \\(x\\) and \\(y\\) directions. Check whether each point lies inside the unit circle by testing if: \\(x^2 + y^2 \\leq 1\\) If true, the point is inside the circle.","title":"2. Simulation:"},{"location":"1%20Physics/6%20Statistics/Problem_2/#3-visualization","text":"Create a plot showing the random points in the square. Points inside the circle will be shown in one color, and points outside will be in another color. Display the circle and square for clarity.","title":"3. Visualization:"},{"location":"1%20Physics/6%20Statistics/Problem_2/#4-analysis","text":"Investigate how the accuracy of the estimate improves as the number of points increases. Discuss the convergence rate and computational considerations for this method.","title":"4. Analysis:"},{"location":"1%20Physics/6%20Statistics/Problem_2/#part-2-estimating-pi-using-buffons-needle","text":"","title":"Part 2: Estimating $ \\pi $ Using Buffon\u2019s Needle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#1-theoretical-foundation_1","text":"The Buffon\u2019s Needle problem involves dropping a needle of length \\(L\\) onto a plane with parallel lines spaced a distance \\(D\\) apart. The probability of the needle crossing a line depends on the angle of the needle and its distance to the nearest line. The formula for estimating \\(\\pi\\) based on this probability is: \\(\\pi = \\frac{2L N_{\\text{drops}}}{D N_{\\text{crosses}}}\\) Where: - \\(L\\) is the length of the needle. - \\(D\\) is the distance between the parallel lines. - \\(N_{\\text{crosses}}\\) is the number of times the needle crosses a line. - \\(N_{\\text{drops}}\\) is the total number of needle drops.","title":"1. Theoretical Foundation:"},{"location":"1%20Physics/6%20Statistics/Problem_2/#2-simulation_1","text":"Simulate the random dropping of a needle onto a plane with parallel lines. For each drop, calculate the distance from the needle\u2019s midpoint to the nearest line and the angle of the needle. Determine whether the needle crosses a line based on the geometric conditions.","title":"2. Simulation:"},{"location":"1%20Physics/6%20Statistics/Problem_2/#3-visualization_1","text":"Create a graphical representation of the simulation. Show the positions of the needles and whether they cross a line or not.","title":"3. Visualization:"},{"location":"1%20Physics/6%20Statistics/Problem_2/#4-analysis_1","text":"Explore how the number of needle drops affects the estimate\u2019s accuracy. Compare the convergence rate of this method to the circle-based approach.","title":"4. Analysis:"},{"location":"1%20Physics/6%20Statistics/Problem_2/#3-python-code-for-circle-based-method","text":"import numpy as np import matplotlib.pyplot as plt # Function to estimate \u03c0 using Monte Carlo method based on circle def estimate_pi_circle(n_points): # Generate random points (x, y) in the square [-1, 1] x [-1, 1] x = np.random.uniform(-1, 1, n_points) y = np.random.uniform(-1, 1, n_points) # Calculate the distance of each point from the origin (x^2 + y^2) distance_squared = x**2 + y**2 # Count the points inside the unit circle (x^2 + y^2 <= 1) points_inside_circle = np.sum(distance_squared <= 1) # Estimate \u03c0 using the ratio of points inside the circle # \u03c0 = 4 * (points inside circle) / (total points) pi_estimate = 4 * points_inside_circle / n_points return pi_estimate, x, y, distance_squared <= 1 # Run the simulation for 10,000 points n_points = 10000 pi_estimate, x, y, inside_circle = estimate_pi_circle(n_points) # Visualize the points and the circle plt.figure(figsize=(6,6)) plt.scatter(x[inside_circle], y[inside_circle], color='green', s=1, label='Inside Circle') plt.scatter(x[~inside_circle], y[~inside_circle], color='red', s=1, label='Outside Circle') plt.gca().set_aspect('equal', adjustable='box') plt.title(f\"Monte Carlo Estimation of $\\\\pi$\\nEstimated $\\\\pi$: {pi_estimate:.4f}\") plt.xlabel('X') plt.ylabel('Y') plt.legend() plt.grid(True) plt.show()","title":"3. Python Code for Circle-Based Method:"},{"location":"1%20Physics/6%20Statistics/Problem_2/#function-to-simulate-buffons-needle","text":"def estimate_pi_buffon(needle_length, line_distance, n_drops): crosses = 0 for _ in range(n_drops): # Randomly generate the distance from the needle's midpoint to the nearest line dist_to_line = np.random.uniform(0, line_distance / 2) # Randomly generate the angle of the needle (uniformly between 0 and \u03c0/2) angle = np.random.uniform(0, np.pi / 2) # Check if the needle crosses the line if dist_to_line <= (needle_length / 2) * np.sin(angle): crosses += 1 # Estimate \u03c0 using Buffon's Needle formula pi_estimate = (2 * needle_length * n_drops) / (line_distance * crosses) return pi_estimate","title":"Function to simulate Buffon's Needle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#run-the-simulation-for-buffons-needle","text":"needle_length = 1 # length of the needle (L) line_distance = 2 # distance between parallel lines (D) n_drops = 10000 # number of needle drops (N_drops)","title":"Run the simulation for Buffon's Needle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#estimate-using-buffons-needle-method","text":"pi_estimate_buffon = estimate_pi_buffon(needle_length, line_distance, n_drops) print(f\"Estimated \u03c0 using Buffon's Needle: {pi_estimate_buffon:.4f}\")","title":"Estimate \u03c0 using Buffon's Needle method"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1 Measuring Earth's Gravitational Acceleration with a Pendulum Motivation: The acceleration due to gravity \\( g \\) is a fundamental constant that influences a wide range of physical phenomena. Measuring \\( g \\) accurately is crucial for understanding gravitational interactions, designing structures, and conducting experiments in various fields. One classic method for determining \\( g \\) is through the oscillations of a simple pendulum, where the period of oscillation depends on the local gravitational field. Task: Measure the acceleration \\( g \\) due to gravity using a pendulum and analyze the uncertainties in the measurements in detail. This exercise emphasizes rigorous measurement practices, uncertainty analysis, and their role in experimental physics. Procedure: 1. Materials: A string (1 or 1.5 meters long). A small weight (e.g., bag of coins, bag of sugar, key chain) mounted on the string. Stopwatch (or smartphone timer). Ruler or measuring tape. 2. Setup: Attach the weight to the string and fix the other end to a sturdy support. Measure the length of the pendulum \\( L \\) , from the suspension point to the center of the weight using a ruler or measuring tape. Record the resolution of the measuring tool and calculate the uncertainty as half the resolution \\( \\Delta L \\) . 3. Data Collection: Displace the pendulum slightly ( \\(< 15^\\circ\\) ) and release it. Measure the time for 10 full oscillations \\( T_{\\text{total}} \\) and repeat this process 10 times. Record all 10 measurements. Calculate the mean time for 10 oscillations \\( \\overline{T_{\\text{total}}} \\) and the standard deviation \\( \\sigma_{T_{\\text{total}}} \\) . Mean Time: $$ \\overline{T_{\\text{total}}} = \\frac{1}{N} \\sum_{i=1}^{N} T_{\\text{total}_i} $$ Standard Deviation: $$ \\sigma_{T_{\\text{total}}} = \\sqrt{\\frac{1}{N-1} \\sum_{i=1}^{N} \\left( T_{\\text{total} i} - \\overline{T {\\text{total}}} \\right)^2} $$ Determine the uncertainty in the mean time as: $$ \\Delta \\overline{T_{\\text{total}}} = \\frac{\\sigma_{T_{\\text{total}}}}{\\sqrt{N}} $$ 4. Calculations: 1. Calculate the period: The period for a simple pendulum is given by the formula: $$ T = 2 \\pi \\sqrt{\\frac{L}{g}} $$ Where: - \\( L \\) is the length of the pendulum, - \\( g \\) is the acceleration due to gravity. Rearranging this equation to solve for \\( g \\) , we get: $$ g = \\frac{4 \\pi^2 L}{T^2} $$ 2. Determine \\( g \\) : Use the mean value of \\( \\overline{T_{\\text{total}}} \\) to calculate the period: $$ T = \\frac{\\overline{T_{\\text{total}}}}{10} $$ Substitute the values of \\( L \\) and \\( T \\) into the equation for \\( g \\) : $$ g = \\frac{4 \\pi^2 L}{\\left( \\frac{\\overline{T_{\\text{total}}}}{10} \\right)^2} $$ 3. Propagate uncertainties: The uncertainty in \\( g \\) due to uncertainties in \\( L \\) and \\( T \\) can be found using the propagation of uncertainty formula: $$ \\Delta g = \\sqrt{\\left( \\frac{\\partial g}{\\partial L} \\Delta L \\right)^2 + \\left( \\frac{\\partial g}{\\partial T} \\Delta T \\right)^2} $$ Where: - \\( \\frac{\\partial g}{\\partial L} = \\frac{4 \\pi^2}{T^2} \\) , - \\( \\frac{\\partial g}{\\partial T} = -\\frac{8 \\pi^2 L}{T^3} \\) . 5. Output the Results: Calculate the uncertainty \\( \\Delta g \\) and print the results. Python Script for Measurement and Uncertainty Calculation: ```python import numpy as np Given data L = 1.0 # Length of the pendulum in meters T_total = np.array([20.5, 20.6, 20.4, 20.7, 20.5, 20.6, 20.5, 20.6, 20.4, 20.5]) # Time for 10 oscillations in seconds N = len(T_total) Step 1: Calculate mean and standard deviation T_mean = np.mean(T_total) T_std = np.std(T_total, ddof=1) Delta_T_mean = T_std / np.sqrt(N) Step 2: Calculate the period (T) T_period = T_mean / 10 # Period for a single oscillation Step 3: Calculate gravitational acceleration (g) g_measured = (4 * np.pi 2 * L) / T_period 2 Step 4: Propagate uncertainties Delta_L = 0.005 # Uncertainty in length (5mm) Delta_T = Delta_T_mean Partial derivatives dgdL = (4 * np.pi 2) / T_period 2 dgdt = - (8 * np.pi 2 * L) / T_period 3 Uncertainty in g Delta_g = np.sqrt((dgdL * Delta_L) 2 + (dgdt * Delta_T) 2) Output results print(f\"Mean time for 10 oscillations: {T_mean:.3f} s\") print(f\"Standard deviation of time: {T_std:.3f} s\") print(f\"Period of oscillation: {T_period:.3f} s\") print(f\"Measured g: {g_measured:.3f} m/s\u00b2\") print(f\"Uncertainty in g: {Delta_g:.3f} m/s\u00b2\")","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#measuring-earths-gravitational-acceleration-with-a-pendulum","text":"","title":"Measuring Earth's Gravitational Acceleration with a Pendulum"},{"location":"1%20Physics/7%20Measurements/Problem_1/#motivation","text":"The acceleration due to gravity \\( g \\) is a fundamental constant that influences a wide range of physical phenomena. Measuring \\( g \\) accurately is crucial for understanding gravitational interactions, designing structures, and conducting experiments in various fields. One classic method for determining \\( g \\) is through the oscillations of a simple pendulum, where the period of oscillation depends on the local gravitational field.","title":"Motivation:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#task","text":"Measure the acceleration \\( g \\) due to gravity using a pendulum and analyze the uncertainties in the measurements in detail. This exercise emphasizes rigorous measurement practices, uncertainty analysis, and their role in experimental physics.","title":"Task:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#procedure","text":"","title":"Procedure:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#1-materials","text":"A string (1 or 1.5 meters long). A small weight (e.g., bag of coins, bag of sugar, key chain) mounted on the string. Stopwatch (or smartphone timer). Ruler or measuring tape.","title":"1. Materials:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#2-setup","text":"Attach the weight to the string and fix the other end to a sturdy support. Measure the length of the pendulum \\( L \\) , from the suspension point to the center of the weight using a ruler or measuring tape. Record the resolution of the measuring tool and calculate the uncertainty as half the resolution \\( \\Delta L \\) .","title":"2. Setup:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#3-data-collection","text":"Displace the pendulum slightly ( \\(< 15^\\circ\\) ) and release it. Measure the time for 10 full oscillations \\( T_{\\text{total}} \\) and repeat this process 10 times. Record all 10 measurements. Calculate the mean time for 10 oscillations \\( \\overline{T_{\\text{total}}} \\) and the standard deviation \\( \\sigma_{T_{\\text{total}}} \\) . Mean Time: $$ \\overline{T_{\\text{total}}} = \\frac{1}{N} \\sum_{i=1}^{N} T_{\\text{total}_i} $$ Standard Deviation: $$ \\sigma_{T_{\\text{total}}} = \\sqrt{\\frac{1}{N-1} \\sum_{i=1}^{N} \\left( T_{\\text{total} i} - \\overline{T {\\text{total}}} \\right)^2} $$ Determine the uncertainty in the mean time as: $$ \\Delta \\overline{T_{\\text{total}}} = \\frac{\\sigma_{T_{\\text{total}}}}{\\sqrt{N}} $$","title":"3. Data Collection:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#4-calculations","text":"","title":"4. Calculations:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#1-calculate-the-period","text":"The period for a simple pendulum is given by the formula: $$ T = 2 \\pi \\sqrt{\\frac{L}{g}} $$ Where: - \\( L \\) is the length of the pendulum, - \\( g \\) is the acceleration due to gravity. Rearranging this equation to solve for \\( g \\) , we get: $$ g = \\frac{4 \\pi^2 L}{T^2} $$","title":"1. Calculate the period:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#2-determine-g","text":"Use the mean value of \\( \\overline{T_{\\text{total}}} \\) to calculate the period: $$ T = \\frac{\\overline{T_{\\text{total}}}}{10} $$ Substitute the values of \\( L \\) and \\( T \\) into the equation for \\( g \\) : $$ g = \\frac{4 \\pi^2 L}{\\left( \\frac{\\overline{T_{\\text{total}}}}{10} \\right)^2} $$","title":"2. Determine \\( g \\):"},{"location":"1%20Physics/7%20Measurements/Problem_1/#3-propagate-uncertainties","text":"The uncertainty in \\( g \\) due to uncertainties in \\( L \\) and \\( T \\) can be found using the propagation of uncertainty formula: $$ \\Delta g = \\sqrt{\\left( \\frac{\\partial g}{\\partial L} \\Delta L \\right)^2 + \\left( \\frac{\\partial g}{\\partial T} \\Delta T \\right)^2} $$ Where: - \\( \\frac{\\partial g}{\\partial L} = \\frac{4 \\pi^2}{T^2} \\) , - \\( \\frac{\\partial g}{\\partial T} = -\\frac{8 \\pi^2 L}{T^3} \\) .","title":"3. Propagate uncertainties:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#5-output-the-results","text":"Calculate the uncertainty \\( \\Delta g \\) and print the results.","title":"5. Output the Results:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#python-script-for-measurement-and-uncertainty-calculation","text":"```python import numpy as np","title":"Python Script for Measurement and Uncertainty Calculation:"},{"location":"1%20Physics/7%20Measurements/Problem_1/#given-data","text":"L = 1.0 # Length of the pendulum in meters T_total = np.array([20.5, 20.6, 20.4, 20.7, 20.5, 20.6, 20.5, 20.6, 20.4, 20.5]) # Time for 10 oscillations in seconds N = len(T_total)","title":"Given data"},{"location":"1%20Physics/7%20Measurements/Problem_1/#step-1-calculate-mean-and-standard-deviation","text":"T_mean = np.mean(T_total) T_std = np.std(T_total, ddof=1) Delta_T_mean = T_std / np.sqrt(N)","title":"Step 1: Calculate mean and standard deviation"},{"location":"1%20Physics/7%20Measurements/Problem_1/#step-2-calculate-the-period-t","text":"T_period = T_mean / 10 # Period for a single oscillation","title":"Step 2: Calculate the period (T)"},{"location":"1%20Physics/7%20Measurements/Problem_1/#step-3-calculate-gravitational-acceleration-g","text":"g_measured = (4 * np.pi 2 * L) / T_period 2","title":"Step 3: Calculate gravitational acceleration (g)"},{"location":"1%20Physics/7%20Measurements/Problem_1/#step-4-propagate-uncertainties","text":"Delta_L = 0.005 # Uncertainty in length (5mm) Delta_T = Delta_T_mean","title":"Step 4: Propagate uncertainties"},{"location":"1%20Physics/7%20Measurements/Problem_1/#partial-derivatives","text":"dgdL = (4 * np.pi 2) / T_period 2 dgdt = - (8 * np.pi 2 * L) / T_period 3","title":"Partial derivatives"},{"location":"1%20Physics/7%20Measurements/Problem_1/#uncertainty-in-g","text":"Delta_g = np.sqrt((dgdL * Delta_L) 2 + (dgdt * Delta_T) 2)","title":"Uncertainty in g"},{"location":"1%20Physics/7%20Measurements/Problem_1/#output-results","text":"print(f\"Mean time for 10 oscillations: {T_mean:.3f} s\") print(f\"Standard deviation of time: {T_std:.3f} s\") print(f\"Period of oscillation: {T_period:.3f} s\") print(f\"Measured g: {g_measured:.3f} m/s\u00b2\") print(f\"Uncertainty in g: {Delta_g:.3f} m/s\u00b2\")","title":"Output results"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}